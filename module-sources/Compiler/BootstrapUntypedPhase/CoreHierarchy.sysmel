## This is the Phase1, where the core basic type system is defined along with the global bindings.
## In this stage the compiler environment itself is completely empty,
## except for a single reference to the bootstrap compiler itself.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Basic trait that provides fundamental methods.
    addBasicTypeNamed: #AnyValueTrait with: __TypeBuilder__ newTrait;

    ## Type theory fundamentals
    addBasicTypeNamed: #Absurd with: __TypeBuilder__ newAbsurdType;
    addBasicTypeNamed: #Trivial with: __TypeBuilder__ newTrivialType;
    
    addBasicTypeNamed: #False with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #True with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Boolean with: (__TypeBuilder__ newSumTypeWith: (False, True));
    addBasicTypeNamed: #Undefined with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Void with: __TypeBuilder__ newTrivialType;

    ## Base type system
    addBasicTypeNamed: #AnyValue with: (__TypeBuilder__ newGCClassWithSlots: #{});

    addBasicTypeNamed: #Object with: (__TypeBuilder__ newGCClassWithSuperclass: AnyValue slots: #{});

    enterTopLevelNamespace;
    enterNamespaceNamed: #Std;
    enterNamespaceNamed: #Reflection;
    addBasicTypeNamed: #ProgramEntityVisibility with: (__TypeBuilder__ newEnumTypeWith: #{
        Undefined: Undefined.
        LexicalScope: __TypeBuilder__ newTrivialType.
        Public: __TypeBuilder__ newTrivialType.
        Protected: __TypeBuilder__ newTrivialType.
        Private: __TypeBuilder__ newTrivialType.
        Internal: __TypeBuilder__ newTrivialType.
    });

    addBasicTypeNamed: #SymbolBinding with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBasicTypeNamed: #SymbolTable with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBasicTypeNamed: #MethodDictionary with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBasicTypeNamed: #ProgramEntity with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});

    enterTopLevelNamespace;
    addBasicTypeNamed: #Type with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection ProgramEntity slots: #{});
    addBasicTypeNamed: #SimpleType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});
    addBasicTypeNamed: #MetaType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});
    addBasicTypeNamed: #Trait with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});

    addBasicTypeNamed: #Tuple with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Function with: (__TypeBuilder__ newGCClassWithSuperclass: SimpleType slots: #{});

    addBasicTypeNamed: #String with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Symbol with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Integer with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Float with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    
    addBasicTypeNamed: #CompilationError with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});

    enterTopLevelNamespace;
    enterNamespaceNamed: #Std;
    enterNamespaceNamed: #Reflection;

    addBasicTypeNamed: #DependentArgumentPlaceholder with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{
        canonicalType: Type
    });

    addBasicTypeNamed: #TypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #TraitTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #TrivialTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #AbsurdTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #SumTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #PrimitiveTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #ProductTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #RecordTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection ProductTypeSchema slots: #{});
    addBasicTypeNamed: #UnionTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection RecordTypeSchema slots: #{});
    addBasicTypeNamed: #GCClassTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection RecordTypeSchema slots: #{});
    addBasicTypeNamed: #ArrayTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #PointerTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});
    addBasicTypeNamed: #ReferenceTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection TypeSchema slots: #{});

    addBasicTypeNamed: #FunctionProgramEntity with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection ProgramEntity slots: #{});
    addBasicTypeNamed: #BootstrapBlockClosure with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection FunctionProgramEntity slots: #{});
    addBasicTypeNamed: #BlockClosure with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection FunctionProgramEntity slots: #{});
    addBasicTypeNamed: #AbstractPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection FunctionProgramEntity slots: #{});
    addBasicTypeNamed: #BootstrapPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #TypeSchemaPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeAccessorPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeGetterPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection RecordTypeAccessorPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeSetterPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection RecordTypeAccessorPrimitiveMethod slots: #{});

    addBindingNamed: #SourceCollection with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourcePosition with: (__TypeBuilder__ newGCClassWithSlots: #{}).

AnyValue addTypeFlag: #anyValue.


## Object primitives.
AnyValue
    withSelector: #== addMethod: {:(AnyValue)self :(AnyValue)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"object.comparison.identityEquals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #~~ addMethod: {:(AnyValue)self :(AnyValue)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"object.comparison.identityNotEquals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #identityHash addMethod: {:(AnyValue)self :: Size |
        <pure>
        <compileTime>
        <primitive: #"object.comparison.identityHash">
        __BootstrapCompiler__ primitiveFailed
    }.

Object
    withSelector: #= addMethod: {:(Object)self :(AnyValue)other :: Boolean |
        <pure>
        <virtual>
        self == other
    };
    withSelector: #~= addMethod: {:(Object)self :(AnyValue)other :: Boolean |
        <pure>
        <virtual>
        self ~~ other
    };
    withSelector: #hash addMethod: {:(Object)self :: Size |
        <pure>
        <virtual>
        self identityHash
    }.

## Boolean primitives
Boolean
    withSelector: #| addMethod: {:(Boolean)self :(Boolean)other :: Boolean |
        <pure>
        <compileTime>
        if: self then: {
            true
        } else: {
            other
        }
    };
    withSelector: #& addMethod: {:(Boolean)self :(Boolean)other :: Boolean |
        <pure>
        <compileTime>
        if: self then: {
            other
        } else: {
            false
        }
    };
    withSelector: #not addMethod: {:(Boolean)self :: Boolean |
        <pure>
        <compileTime>
        if: self then: {
            false
        } else: {
            true
        }
    }.

## Integer arithmetics primitive methods
Integer
    withSelector: #negated addMethod: {:(Integer)self :: Integer |
        <pure>
        <compileTime>
        <primitive: #"integer.arithmetic.neg">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #+ addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <compileTime>
        <primitive: #"integer.arithmetic.add">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #- addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <compileTime>
        <primitive: #"integer.arithmetic.sub">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #"*" addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <compileTime>
        <primitive: #"integer.arithmetic.mul">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #// addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <compileTime>
        <primitive: #"integer.arithmetic.div">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #% addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <compileTime>
        <primitive: #"integer.arithmetic.rem">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #= addMethod: {:(Integer)self :(Object)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"integer.comparison.equals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #~= addMethod: {:(Integer)self :(Object)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"integer.comparison.notEquals">
        __BootstrapCompiler__ primitiveFailed
    };
    
    withSelector: #< addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"integer.comparison.lessThan">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #<= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"integer.comparison.lessOrEqual">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #> addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"integer.comparison.greaterThan">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #>= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <compileTime>
        <primitive: #"integer.comparison.greaterOrEqual">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #asString addMethod: {:(Integer)self :: String |
        <pure>
        <compileTime>
        <primitive: #"integer.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Integer)self :: String |
        <pure>
        <compileTime>
        <primitive: #"integer.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    }.

AnyValueTrait
    withSelector: #initialize addMethod: {:(AnyValueTrait)self :: Void |
        void
    };
    withSelector: #__type__ addMethod: {:(AnyValueTrait)self :: Type |
        <pure>
        <compileTime>
        self __basicType__
    };
    withSelector: #yourself addMethod: {:(AnyValueTrait)self :: self __type__ |
        <pure>
        <compileTime>
        self
    }.

Std Reflection DependentArgumentPlaceholder
    withSelector: #__type__ addMethod: {:(Std Reflection DependentArgumentPlaceholder)self :: Type |
        <pure>
        <compileTime>
        self canonicalType
    }.
 
Type
    withSelector: #"()" addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    };
    withSelector: #"#{}:" addMethod: {:(Type)self :(AnyValue)slotPairs :: self |
        (self basicNewWithNamedSlots: slotPairs) initialize; yourself
    };
    withSelector: #new addMethod: {:(Type)self :: self |
        self basicNew initialize; yourself
    }.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Important keywords
    addKeywordBindingNamed: #void with: Void basicNew;
    addKeywordBindingNamed: #false with: False new;
    addKeywordBindingNamed: #true with: True new;
    addKeywordBindingNamed: #nil with: Undefined new;

    ## The primitive types
    addBasicTypeNamed: #Boolean8 with: (__TypeBuilder__ newBooleanTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Boolean16 with: (__TypeBuilder__ newBooleanTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Boolean32 with: (__TypeBuilder__ newBooleanTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #UInt8 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #UInt16 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #UInt32 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #UInt64 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Int8 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Int16 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Int32 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Int64 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Char8 with: (__TypeBuilder__ newCharacterTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Char16 with: (__TypeBuilder__ newCharacterTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Char32 with: (__TypeBuilder__ newCharacterTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #Float16 with: (__TypeBuilder__ newFloatTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Float32 with: (__TypeBuilder__ newFloatTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Float64 with: (__TypeBuilder__ newFloatTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #UIntPointer with: (if: __BootstrapCompiler__ getPointerSize = 4 then: UInt32 else: UInt64);
    addBasicTypeNamed: #IntPointer with: (if: __BootstrapCompiler__ getPointerSize = 4 then: Int32 else: Int64);
    addBasicTypeNamed: #Size with: UIntPointer.

## Integer conversion primitives
Integer
    withSelector: #u8 addMethod: {:(Integer)self :: UInt8 |
        <pure>
        <primitive: #"integer.conversion.toUInt8">
        UInt8 basicNew: self
    };
    withSelector: #i8 addMethod: {:(Integer)self :: Int8 |
        <pure>
        <primitive: #"integer.conversion.toInt8">
        Int8 basicNew: self
    };
    withSelector: #u16 addMethod: {:(Integer)self :: UInt16 |
        <pure>
        <primitive: #"integer.conversion.toUInt16">
        UInt16 basicNew: self
    };
    withSelector: #i16 addMethod: {:(Integer)self :: Int16 |
        <pure>
        <primitive: #"integer.conversion.toInt16">
        Int16 basicNew: self
    };
    withSelector: #u32 addMethod: {:(Integer)self :: UInt32 |
        <pure>
        <primitive: #"integer.conversion.toUInt32">
        UInt32 basicNew: self
    };
    withSelector: #i32 addMethod: {:(Integer)self :: Int32 |
        <pure>
        <primitive: #"integer.conversion.toInt32">
        Int32 basicNew: self
    };
    withSelector: #u64 addMethod: {:(Integer)self :: UInt64 |
        <pure>
        <primitive: #"integer.conversion.toUInt64">
        UInt64 basicNew: self
    };
    withSelector: #i64 addMethod: {:(Integer)self :: Int64 |
        <pure>
        <primitive: #"integer.conversion.toInt64">
        Int64 basicNew: self
    };

    withSelector: #sz addMethod: {:(Integer)self :: Size |
        <pure>
        <primitive: #"integer.conversion.toSize">
        Size basicNew: self
    };
    withSelector: #uptr addMethod: {:(Integer)self :: UIntPointer |
        <pure>
        <primitive: #"integer.conversion.toUIntPointer">
        UIntPointer basicNew: self
    };
    withSelector: #uptr addMethod: {:(Integer)self :: IntPointer |
        <pure>
        <primitive: #"integer.conversion.toIntPointer">
        IntPointer basicNew: self
    }.

{:addPrimitivesBlock |
    addPrimitivesBlock(UInt8).
    addPrimitivesBlock(Int8).
    addPrimitivesBlock(UInt16).
    addPrimitivesBlock(Int16).
    addPrimitivesBlock(UInt32).
    addPrimitivesBlock(Int32).
    addPrimitivesBlock(UInt64).
    addPrimitivesBlock(Int64).
}({:(Type)primitiveIntegerType |
    primitiveIntegerType
        withSelector: #negated addMethod: {:(primitiveIntegerType)self :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.neg">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #+ addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.add">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #- addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.sub">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #"*" addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.mul">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #// addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.div">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #% addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.rem">
            __BootstrapCompiler__ primitiveFailed
        };

        withSelector: #= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.equals">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #~= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.notEquals">
            __BootstrapCompiler__ primitiveFailed
        };
        
        withSelector: #< addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.lessThan">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #<= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.lessOrEqual">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #> addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.greaterThan">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #>= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.greaterOrEqual">
            __BootstrapCompiler__ primitiveFailed
        };

        withSelector: #min: addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            if: self <= other
                then: self
                else: other
        };
        withSelector: #max: addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            if: self >= other
                then: self
                else: other
        };

        withSelector: #asString addMethod: {:(Integer)self :: String |
            <pure>
            <primitive: #"primitiveInteger.conversion.toString">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #printString addMethod: {:(Integer)self :: String |
            <pure>
            <primitive: #"primitiveInteger.conversion.toString">
            __BootstrapCompiler__ primitiveFailed
        }.
}).

__BootstrapCompiler__
    enterTopLevelNamespace;
    
    ## The polymorphic types
    addBasicTypeNamed: #Optional with: {:(Type)optionalType :: Type |
        <pure>
        <compileTime>
        let: #sumType with: (__TypeBuilder__ newSumTypeWith: (Undefined, optionalType)).

        sumType
            withSelector: #isNil addMethod: {:(sumType)self :: Boolean |
                <pure>
                <compileTime>
                self __typeSelector__ = 0sz
            };
            withSelector: #isNotNil addMethod: {:(sumType)self :: Boolean |
                <pure>
                <compileTime>
                self __typeSelector__ ~= 0sz
            };
            withSelector: #_ addMethod: {:(sumType)self :: optionalType |
                <pure>
                <compileTime>
                self get: optionalType
            };
            withSelector: #value addMethod: {:(sumType)self :: optionalType |
                <pure>
                <compileTime>
                self get: optionalType
            }.
        sumType
    } templated;

    addBasicTypeNamed: #Array with: {:(Type)elementType :(Size)bounds :: Type |
        <pure>
        <compileTime>
        let: #arrayType with: (__TypeBuilder__ newArrayTypeFor: elementType withBounds: bounds).
        arrayType
            withSelector: #asArraySlice addMethod: {:(arrayType)self :: ArraySlice(elementType) |
                <pure>
                <compileTime>
                ArraySlice(elementType)#{
                    elements: self.
                    size: bounds
                }
            };
            withSelector: #asSharedArraySlice addMethod: {:(arrayType)self :: SharedArraySlice(elementType) |
                <pure>
                <compileTime>
                ## TODO: Make a shared copy if needed.
                SharedArraySlice(elementType)#{
                    elements: self.
                    size: bounds.
                    storage: self
                }
            };
            withSelector: #at: addMethod: {:(arrayType)self :(Size)index :: elementType |
                <pure>
                <compileTime>
                <primitive: #"array.basicAt">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #at:put: addMethod: {:(arrayType)self :(Size)index :(elementType)value :: elementType |
                <compileTime>
                <primitive: #"array.basicAtPut">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #size addMethod: {:(arrayType)self :: Size |
                <pure>
                <compileTime>
                bounds
            }.
        arrayType
    } templated;

    addBasicTypeNamed: #Pointer with: {:(Type)elementType :(Symbol)addressSpace :: Type |
        <pure>
        <compileTime>
        let: #pointerType with: (__TypeBuilder__ newPointerTypeFor: elementType addressSpace: addressSpace).

        pointerType __type__
            withSelector: #allocate: addMethod: {:(pointerType __type__)self :(Size)count :: pointerType |
                <pure>
                <compileTime>
                <primitive: #"pointer.allocateWithCount">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #allocate addMethod: {:(pointerType __type__)self :: pointerType |
                <pure>
                <compileTime>
                self allocate: 1
            }.

        pointerType
            withSelector: #at: addMethod: {:(pointerType)self :(Size)index :: elementType |
                <pure>
                <compileTime>
                <primitive: #"pointer.basicAt">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #at:put: addMethod: {:(pointerType)self :(Size)index :(elementType)value :: elementType |
                <compileTime>
                <primitive: #"pointer.basicAtPut">
                __BootstrapCompiler__ primitiveFailed
            }.

        pointerType
    } templated;
    addBasicTypeNamed: #SharedPointer with: {:(Type)elementType :: Type |
        <pure>
        <compileTime>
        Pointer(elementType, #shared)
    };

    addBasicTypeNamed: #ArraySlice with: {:(Type)elementType :: Type |
        <pure>
        <compileTime>
        let: #arraySliceType with: (__TypeBuilder__ newRecordTypeWith: #{
            elements: Pointer(elementType, #generic).
            size: Size.
        }).

        arraySliceType
            addTypeFlag: #arraySlice;
            withSelector: #isEmpty addMethod: {:(arraySliceType)self :: Boolean |
                <pure>
                <compileTime>
                self size = 0sz
            };
            withSelector: #isNotEmpty addMethod: {:(arraySliceType)self :: Boolean |
                <pure>
                <compileTime>
                self size ~= 0sz
            };
            withSelector: #at: addMethod: {:(arraySliceType)self :(Size)index :: elementType |
                <pure>
                <compileTime>
                self elements at: index
            };
            withSelector: #at:put: addMethod: {:(arraySliceType)self :(Size)index :(elementType)element :: elementType |
                <compileTime>
                self elements at: index put: element
            };
            withSelector: #first addMethod: {:(arraySliceType)self :: elementType |
                <pure>
                <compileTime>
                self at: 0sz
            };
            withSelector: #second addMethod: {:(arraySliceType)self :: elementType |
                <pure>
                <compileTime>
                self at: 1sz
            };
            withSelector: #last addMethod: {:(arraySliceType)self :: elementType |
                <pure>
                <compileTime>
                self at: self size - 1sz
            };
            withSelector: #until: addMethod: {:(arrayType)self :(Size)newSize :: Size |
                <pure>
                <compileTime>
                arraySliceType #{
                    elements: Pointer(elementType, #generic).
                    size: (self size min: newSize).
                }
            };
            withSelector: #collect: addMethod: {:(arraySliceType)self :*(Type)ResultType :(elementType => ResultType)block :: SharedArraySlice(ResultType) |
                <pure>
                <compileTime>
                <primitive: #"arraySlice.collect">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #collectWithIndex: addMethod: {:(arraySliceType)self :*(Type)ResultType :((elementType -- Size) => ResultType)block :: SharedArraySlice(ResultType) |
                <pure>
                <compileTime>
                <primitive: #"arraySlice.collectWithIndex">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #do: addMethod: {:(arraySliceType)self :((elementType) => Void)block :: Void |
                <pure>
                <compileTime>
                let: #index with: (Size valueBox with: 0sz).                
                while: index _ < self size do: {
                    block(self at: index _).
                } continueWith: (index _: index _ + 1sz).
                void
            };
            withSelector: #anySatisfy: addMethod: {:(arraySliceType)self :((elementType) => Boolean)block :: Boolean |
                <pure>
                <compileTime>
                let: #result with: (Boolean valueBox with: false).
                let: #index with: (Size valueBox with: 0sz).                
                while: (if: result _ not then: index _ < self size else: false) do: {
                    if: block(self at: index _) then: {
                        void
                    } else: {
                        result _: true
                    }
                } continueWith: (index _: index _ + 1sz).
                result _
            };
            withSelector: #allSatisfy: addMethod: {:(arraySliceType)self :((elementType) => Boolean)block :: Boolean |
                <pure>
                <compileTime>
                let: #result with: (Boolean valueBox with: true).
                let: #index with: (Size valueBox with: 0sz).                
                while: (if: result _ then: index _ < self size else: false) do: {
                    if: block(self at: index _) then: {
                        void
                    } else: {
                        result _: false
                    }
                } continueWith: (index _: index _ + 1sz).
                result _
            };
            withSelector: #doWithIndex: addMethod: {:(arraySliceType)self :((elementType -- Size) => Void)block :: Void |
                <pure>
                <compileTime>
                let: #index with: (Size valueBox with: 0sz).                
                while: index _ < self size do: {
                    block(self at: index _, index _).
                } continueWith: (index _: index _ + 1sz).
                void
            };
            withSelector: #allButFirst: addMethod: {:(arraySliceType)self :(Size)itemsToDrop :: SharedArraySlice(elementType) |
                <pure>
                <compileTime>
                let: #resultSize with: (if: itemsToDrop - self size then: self size - itemsToDrop else: 0).
                let: #index with: (Size valueBox with: 0sz).                
                let: #result with: (SharedArraySlice(elementType) allocate: resultSize).

                while: index _ < resultSize do: {
                    result at: index _ put: (self at: itemsToDrop + index _)
                } continueWith: (index _: index _ + 1sz).

                result
            };
            withSelector: #allButFirst addMethod: {:(arraySliceType)self :: SharedArraySlice(elementType) |
                <pure>
                <compileTime>
                self allButFirst: 1sz
            };
            withSelector: #-- addMethod: {:(arraySliceType)self :(arraySliceType)other :: SharedArraySlice(elementType) |
                <pure>
                <compileTime>
                let: #result with: (SharedArraySlice(elementType) allocate: self size + other size).
                let: #index with: (Size valueBox with: 0sz).                
                while: index _ < self size do: {
                    result at: index _ put: (self at: index _)
                } continueWith: (index _: index _ + 1sz).

                index _: 0sz.
                while: index _ < other size do: {
                    result at: self size + index _ put: (other at: index _)
                } continueWith: (index _: index _ + 1sz).

                result
            }.
        arraySliceType
    } templated;
    addBasicTypeNamed: #AnyArraySlice with: ArraySlice(AnyValue);

    addBasicTypeNamed: #SharedArraySlice with: {:(Type)elementType :: Type |
        <pure>
        <compileTime>
        let: #storagePointerType with: SharedPointer(elementType).
        let: #sharedArraySliceType with: (__TypeBuilder__ newRecordTypeWithSupertype: ArraySlice(elementType) with: #{
            storage: storagePointerType
        }).

        sharedArraySliceType addTypeFlag: #arraySlice.
        sharedArraySliceType __type__
            withSelector: #allocate: addMethod: {:(sharedArraySliceType)self :(Size)size :: sharedArraySliceType |
                <pure>
                <compileTime>
                let: #storage with: (storagePointerType allocate: size).
                sharedArraySliceType#{
                    elements: storage.
                    size: size.
                    storage: storage
                }.
            };
            withSelector: #with: addMethod: {:(sharedArraySliceType)self :(elementType)first :: sharedArraySliceType |
                <pure>
                <compileTime>
                let: #result with: (self allocate: 1sz).
                result
                    at: 0sz put: first;
                    yourself
            };
            withSelector: #with:with: addMethod: {:(sharedArraySliceType)self :(elementType)first :(elementType)second :: sharedArraySliceType |
                <pure>
                <compileTime>
                let: #result with: (self allocate: 2sz).
                result
                    at: 0sz put: first;
                    at: 1sz put: second;
                    yourself
            }.

        sharedArraySliceType
    } templated;
    addBasicTypeNamed: #AnySharedArraySlice with: SharedArraySlice(AnyValue);

    addBasicTypeNamed: #Association with: {:(Type)key :(Type)value :: Type |
        <pure>
        <compileTime>
        __TypeBuilder__ newRecordTypeWith: #{
            key: key.
            value: value.
        }
    } templated;
    addBasicTypeNamed: #AnyAssociation with: Association(AnyValue, AnyValue);

    addBasicTypeNamed: #ArrayDictionary with: {:(Type)keyType :(Type)valueType :: Type |
        <pure>
        <compileTime>
        __TypeBuilder__ newRecordTypeWith: #{
            associationList: ArraySlice(Association(keyType, valueType)).
            hashTable: ArraySlice(UInt32).
        }
    } templated;
    addBasicTypeNamed: #AnyArrayDictionary with: ArrayDictionary(AnyValue, AnyValue);

    addBasicTypeNamed: #ArrayList with: {:(Type)elementType :: Type |
        <pure>
        <compileTime>
        let: #storageType with: SharedArraySlice(elementType).
        let: #arrayListType with: (__TypeBuilder__ newRecordTypeWith: #{
            size: Size.
            storage: storageType
        }).

        arrayListType
            withSelector: #add: addMethod: {:(arrayListType)self :(elementType)element :: Void |
                <compileTime>
                if: self size >= self storage size then: {
                    self increaseCapacity.
                } else: {void}.

                self storage at: self size put: element.
                self size: self size + 1sz.
                void
            };
            withSelector: #increaseCapacity addMethod: {:(arrayListType)self :: Void |
                <compileTime>
                let: #oldCapacity with: self storage size.
                let: #newCapacity with: (oldCapacity max: 8sz).
                let: #oldStorage with: self storage.
                let: #newStorage with: (storageType allocate: newCapacity).
                let: #index with: (Size valueBox with: 0sz).
                while: index _ < oldCapacity do: {
                    newStorage at: index put: (oldStorage at: index) 
                } continueWith: (index _: index _ + 1sz).

                self storage: newStorage.
                void
            };
            withSelector: #at: addMethod: {:(arrayListType)self :(Size)index :: elementType |
                <compileTime>
                if: index < self size then: {
                    self storage at: index
                } else: {
                    __BootstrapCompiler__ error: "Index out of bounds"
                }
            };
            withSelector: #at:put: addMethod: {:(arrayListType)self :(Size)index :(elementType)element :: Void |
                <compileTime>
                if: index < self size then: {
                    self storage at: index put: element
                } else: {
                    __BootstrapCompiler__ error: "Index out of bounds"
                }
            };
            withSelector: #asArraySlice addMethod: {:(arrayListType)self :: ArraySlice(elementType) |
                <pure>
                <compileTime>
                storage until: self size
            }.

        arrayListType
    } templated;
    addBasicTypeNamed: #AnyArrayList with: ArrayList(AnyValue);

    addBasicTypeNamed: #Tuple with: {:*(Size)N :(Type array: N)elementTypes :: Type |
        <pure>
        <compileTime>
        let: #tupleSize with: elementTypes size.
        let: #tupleType with: (__TypeBuilder__ newProductTypeWith: elementTypes).
        tupleType __type__
            withSelector: #-- addMethod: {:(Type)self :(Type)nextType :: Type |
                <override>
                <compileTime>
                __TypeBuilder__ extendTupleType: self with: nextType
            };
            withSelector: #=> addMethod: {:(Type)self :(Type)resultType :: Type |
                <override>
                <compileTime>
                __TypeBuilder__ newSimpleFunctionTypeWithArguments: self resultType: resultType
            }.

        tupleType
            withSelector: #at: addMethod: {:(tupleType)self :(Size)elementIndex :: (elementTypes at: elementIndex) |
                <pure>
                <compileTime>
                <primitive: #"tuple.accessing.at">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #at:put: addMethod: {:(tupleType)self :(Size)elementIndex :(elementTypes at: elementIndex)element :: (elementTypes at: elementIndex) |
                <pure>
                <compileTime>
                <primitive: #"tuple.accessing.atPut">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #size addMethod: {:(tupleType)self :: Size |
                <pure>
                <compileTime>
                tupleSize
            }.
        tupleType
    } templated;

    addBasicTypeNamed: #ValueBox with: {:(Type)elementType :: Type |
        <pure>
        <compileTime>
        let: #valueBoxType with: (__TypeBuilder__ newRecordTypeWith: #{
            _: elementType
        }).
        valueBoxType __type__
            withSelector: #with: addMethod: {:(valueBoxType __type__)self :(elementType)value :: self |
                self#{
                    _: value
                }
            }.
        valueBoxType
    } templated;
    addBasicTypeNamed: #AnyValueBox with: ArrayList(AnyValue).

## String primitive methods
String
    withSelector: #-- addMethod: {:(String)self :(String)other :: String |
        <pure>
        <compileTime>
        <primitive: #"string.concat">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #format: addMethod: {:(String)self :(String arraySlice)parameters :: String |
        <pure>
        <compileTime>
        <primitive: #"string.format">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asSymbol addMethod: {:(String)self :: Symbol |
        <pure>
        <compileTime>
        <primitive: #"symbol.internString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asString addMethod: {:(String)self :: String |
        <pure>
        <compileTime>
        self
    };
    withSelector: #printString addMethod: {:(String)self :: String |
        <pure>
        <compileTime>
        <primitive: #"string.conversion.printString">
        self
    };
    withSelector: #withoutSuffix: addMethod: {:(Symbol)self :(String)suffix :: String |
        <pure>
        <compileTime>
        <primitive: #"string.manipulations.withoutSuffix">
        __BootstrapCompiler__ primitiveFailed
    }.


Symbol
    withSelector: #asString addMethod: {:(Symbol)self :: String |
        <pure>
        <compileTime>
        <primitive: #"symbol.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Symbol)self :: String |
        <pure>
        <compileTime>
        <primitive: #"symbol.conversion.printString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #withoutSuffix: addMethod: {:(Symbol)self :(String)suffix :: Symbol |
        <pure>
        <compileTime>
        <primitive: #"symbol.manipulations.withoutSuffix:">
        (self asString withoutSuffix: suffix) asSymbol
    }.

## Basic type system methods.
Type
    withSelector: #-- addMethod: {:(Type)self :(Type)second :: Type |
        <pure>
        <compileTime>
        <virtual>
        __TypeBuilder__ newPairType: self with: second
    };
    withSelector: #=> addMethod: {:(Type)self :(Type) resultType :: Type |
        <pure>
        <compileTime>
        <virtual>
        __TypeBuilder__ newSimpleFunctionTypeWithArgument: self resultType: resultType
    }.

Void __type__
    withSelector: #=> addMethod: {:(Type)self :(Type) resultType :: Type |
        <pure>
        <compileTime>
        <override>
        __TypeBuilder__ newSimpleFunctionTypeWithResultType: resultType
    }.

## Basic type system methods.
Type
    withSelector: #"[]" addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        Array(self, 0)
    };
    withSelector: #"[]:" addMethod: {:(Type)self :(Size)bounds :: Type |
        <pure>
        <compileTime>
        Array(self, bounds)
    };
    withSelector: #optional addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        Optional(self)
    };
    withSelector: #array addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        Array(self, 0)
    };
    withSelector: #array: addMethod: {:(Type)self :(Size)bounds :: Type |
        <pure>
        <compileTime>
        Array(self, bounds)
    };
    withSelector: #arraySlice addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        ArraySlice(self)
    };
    withSelector: #sharedArraySlice addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        SharedArraySlice(self)
    };
    withSelector: #arrayList addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        ArrayList(self)
    };
    withSelector: #valueBox addMethod: {:(Type)self :: Type |
        <pure>
        <compileTime>
        ValueBox(self)
    }.

## Basic methods.
AnyValue
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <compileTime>
        <virtual>
        false
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <compileTime>
        <virtual>
        true
    }.

Undefined
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <compileTime>
        <override>
        true
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <compileTime>
        <override>
        false
    }.

Std Reflection ProgramEntity definePublicSlots: #{
    parent: Std Reflection ProgramEntity optional.
    name: String optional.
}.

Type definePublicSlots: #{
    supertype: Type optional.
    schema: Std Reflection TypeSchema.
    symbolTable: Std Reflection SymbolTable
}.

Function definePublicSlots: #{
    bootstrapImplementation: Std Reflection FunctionProgramEntity optional.
    implementation: Std Reflection FunctionProgramEntity optional.
}.

__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Std;
    enterNamespaceNamed: #Reflection;
    addBasicTypeNamed: #Namespace with: (__TypeBuilder__ newGCClassWithSuperclass: Std Reflection ProgramEntity slots: #{
        symbolTable: Std Reflection SymbolTable
    }).