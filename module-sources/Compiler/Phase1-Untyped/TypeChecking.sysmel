Type
    withSelector: #asString addMethod: {:(Type)self :: String |
        <pure>
        <primitive: #"type.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Type)self :: String |
        <pure>
        <primitive: #"type.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canHaveTypes addMethod: {:(Reflection Namespace)self :: Boolean |
        true
    };
    withSelector: #canHaveFunctions addMethod: {:(Reflection ProgramEntity)self :: Boolean |
        true
    };
    withSelector: #canHaveMethods addMethod: {:(Reflection Namespace)self :: Boolean |
        true
    };
    withSelector: #asReceiverType addMethod: {:(Reflection ProgramEntity)self :: Type optional |
        self
    };
    withSelector: #lookupPublicSymbol: addMethod: {:(Type)self :(Object)symbol :: Reflection SymbolBinding optional |
        self symbolTable lookupSymbol: symbol
    };
    withSelector: #lookupScopeSymbol: addMethod: {:(Type)self :(Object)symbol :: Reflection SymbolBinding optional |
        self symbolTable lookupSymbol: symbol
    };
    withSelector: #setSymbol:visibility:immutableValue: addMethod: {:(Type)self :(Object)symbol :(Reflection ProgramEntityVisibility)visibility :(AnyValue)immutableValue :: Void |
        self symbolTable setSymbol: symbol immutableValue: immutableValue
    };
    withSelector: #lookupMacroSelector: addMethod: {:(Type)self :(AnyValue)selector :: AnyValue |
        <primitive: #"type.lookupMacroSelector">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :(AnyValue)selector :: AnyValue |
        <primitive: #"type.lookupSelector">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupMacroFallbackSelector: addMethod: {:(Type)self :(AnyValue)selector :: AnyValue |
        <primitive: #"type.lookupMacroFallbackSelector">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSelector:withExpansionLevel: addMethod: {:(Type)self :(AnyValue)selector :(Reflection AST MessageSendExpansionLevel)expansionLevel :: AnyValue |
        if: (expansionLevel is: Reflection AST MessageSendExpansionLevel Macro) then: {
            let: #result with: (self lookupMacroSelector: selector).
            if: result isNotNil then: {
                result
            } else: {
                self lookupSelector: selector withExpansionLevel: (Reflection AST MessageSendExpansionLevel basicNew: Reflection AST MessageSendExpansionLevel Method basicNew)
            }.
        } else: {
            if: (expansionLevel is: Reflection AST MessageSendExpansionLevel Method) then: {
                let: #result with: (self lookupSelector: selector).
                if: result isNotNil then: {
                    result
                } else: {
                    self lookupSelector: selector withExpansionLevel: (Reflection AST MessageSendExpansionLevel basicNew: Reflection AST MessageSendExpansionLevel Method basicNew)
                }.
            } else: {
                self lookupMacroFallbackSelector: selector
            }.
        }.
    };
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self analyzeNormalMessageSendNode: node with: analyzer
    };
    withSelector: #analyzeNormalMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: node selector isLiteralValueNode then: {
            let: #selector with: (node selector evaluateLiteralValue).
            let: #method with: (self lookupSelector: selector withExpansionLevel: node expansionLevel).

            if: method isNil then: {
                self analyzeUnboundMessageSendNode: node with: analyzer
            } else: {
                method analyzeMessageSendNode: node with: analyzer
            }
        } else: {
            self analyzeUnboundOrDynamicMessageSendNode: node with: analyzer
        }
    };
    withSelector: #analyzeUnboundMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self analyzeUnboundOrDynamicMessageSendNode: node with: analyzer
    };
    withSelector: #analyzeUnboundOrDynamicMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self hasAnyValueFlag then: {
            self analyzeDynamicMessageSendNode: node with: analyzer
        } else: {
            __BootstrapCompiler__ printLine: "Selector node".
            __BootstrapCompiler__ printLine: node selector.
            __BootstrapCompiler__ printLine: "Receiver type".
            __BootstrapCompiler__ printLine: node receiver _ analyzedType _.
            analyzer makeSemanticAnalysisError: "Unsupported dynamic message send." at: node sourcePosition
        }
    };
    withSelector: #analyzeDynamicMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedNode with: node shallowCopy.
        analyzedNode
            selector: (analyzer analyzeNodeIfNeeded: analyzedNode selector withExpectedType: self);
            arguments: (node arguments collect: {:(Reflection AST Node)argumentNode :: Reflection AST Node |
                analyzer analyzeNodeIfNeeded: argumentNode withExpectedType: AnyValue
            });
            usesDynamicDispatch: true;
            yourself
    };
    withSelector: #analyzeIdentifierReferenceNode:with:valueBinding: addMethod: {:(Type)self :(Reflection AST IdentifierReferenceNode)node :(Reflection Semantic ASTAnalyzer)analyzer :(Reflection Semantic SymbolValueBinding)binding :: Reflection AST Node |
        Reflection AST LiteralValueNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            analyzedType: self.
            value: binding value
        }
    };
    withSelector: #supportsDynamicDispatch addMethod: {:(Type)self :: AnyValue |
        <primitive: #"type.supportsDynamicDispatch">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asReferenceDecayedType addMethod: {:(Type)self :: Type |
        self
    };
    withSelector: #asDecayedType addMethod: {:(Type)self :: Type |
        self
    };
    withSelector: #isSubtypeOf: addMethod: {:(Type)self :(Type)other :: Boolean |
        <primitive: #"type.isSubtypeOf">
        if: self == other then: {
            true
        } else: {
            if: self supertype isNil then: {
                false
            } else: {
                self supertype _ isSubtypeOf: other
            }
        }
    };
    withSelector: #hasTypeFlag: addMethod: {:(Type)self :(AnyValue)methodFlag :: Boolean |
        <primitive: #"type.hasTypeFlag">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #hasAnyValueFlag addMethod: {:(Type)self :: Boolean |
        self hasTypeFlag: #anyValue
    };

    withSelector: #addImplicitCoercionToNode:targetType:with: addMethod: {:(Type)self
        :(Reflection AST Node)node :(Type)targetType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self == targetType then: {
            node
        } else: {
            if: (self isSubtypeOf: targetType) then: {
                Reflection AST UpcastConversionNode basicNewWithNamedSlots: #{
                    sourcePosition: node sourcePosition.
                    expression: node.
                    analyzedType: targetType
                }
            } else: {
                targetType addImplicitCoercionToNode: node fromType: self with: analyzer
            }
        }
    };
    withSelector: #addImplicitCoercionToNode:fromType:with: addMethod: {:(Type)self
        :(Reflection AST Node)node :(Type)fromType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self == fromType then: {
            node
        } else: {
            if: self hasAnyValueFlag then: {
                Reflection AST WrapAnyValueNode basicNewWithNamedSlots: #{
                    sourcePosition: node sourcePosition.
                    expression: node.
                    analyzedType: self
                }
            } else: {
                if: (self schema canConstructWithValueOfType: fromType) then: {
                    self schema addConstructionNodeFor: node valueType: fromType into: self with: analyzer
                } else: {
                    analyzer makeSemanticAnalysisError: ("Failed to perform implicit conversion {0} -> {1}" format: (fromType printString, self printString)) at: node sourcePosition
                }
            }
        }
    }.

Reflection TypeSchema 
    withSelector: #canConstructWithValueOfType: addMethod: {:(TypeSchema)self :(Type)sourceType :: Boolean |
        false
    };
    withSelector: #addConstructionNodeFor:valueType:into:with: addMethod: {:(TypeSchema)self :(Reflection AST Node)node :(Type)sourceType :(Type)targetType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        __BootstrapCompiler__ subclassResponsibility
    }.

Reflection SumTypeSchema 
    withSelector: #containsType: addMethod: {:(SumTypeSchema)self :(Type)typeToCheck :: Boolean |
        <primitive: #"sumTypeSchema.containsType" >
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #getTypeSelectorIndexFor: addMethod: {:(SumTypeSchema)self :(Type)elementType :: Size |
        <primitive: #"sumTypeSchema.getTypeSelectorIndexFor" >
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canConstructWithValueOfType: addMethod: {:(SumTypeSchema)self :(Type)sourceType :: Boolean |
        self containsType: sourceType
    };
    withSelector: #addConstructionNodeFor:valueType:into:with: addMethod: {:(TypeSchema)self :(Reflection AST Node)node :(Type)sourceType :(Type)targetType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        Reflection AST WrapValueInSumTypeNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            expression: node.
            typeSelector: (self getTypeSelectorIndexFor: sourceType).
            analyzedType: targetType.
        }
    }.

Void __type__
    withSelector: #addImplicitCoercionToNode:fromType:with: addMethod: {:(Type)self
        :(Reflection AST Node)node :(Type)fromType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self == fromType then: {
            node
        } else: {
            Reflection AST ValueAsVoidNode basicNewWithNamedSlots: #{
                sourcePosition: node sourcePosition.
                expression: node.
                analyzedType: self
            }
        }
    }.

