__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;
    enterNamespaceNamed: #AST;
    addBindingNamed: #MethodDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST ProgramEntityDefinitionNode publicSlots: #{
        selectorExpression: Reflection AST Node optional.
        arguments: Reflection AST Node sharedArraySlice.
        resultTypeExpression: Reflection AST Node optional.
        body: Reflection AST Node optional.
        visibility: Reflection ProgramEntityVisibility.
        analyzedSelector: Object optional.
        analyzedOwnerProgramEntity: Reflection ProgramEntity optional.
        analyzedBlockClosureNode: Reflection AST Node optional.
    }).

Reflection AST MethodDefinitionNode
    withSelector: #makeImplicitArgumentsFor: addMethod: {:(Reflection AST MethodDefinitionNode)self :(Reflection ProgramEntity)programEntity :: Reflection AST Node sharedArraySlice |
        let: #receiverType with: programEntity asReceiverType.
        if: receiverType isNil then: {
            Reflection AST Node sharedArraySlice basicNew
        } else: {
            Reflection AST Node sharedArraySlice with:
                ((Reflection AST ArgumentDefinitionNode withName: #self type: receiverType _ at: self sourcePosition)
                    isImplicitArgument: true;
                    yourself)
        }
    };
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST MethodDefinitionNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #ownerProgramEntity with: (analyzer environment lexicalScope lookupCurrentProgramEntity).
        let: #hasValidOwner with: (if: ownerProgramEntity isNotNil then: ownerProgramEntity _ canHaveMethods else: false).

        let: #selector with: (if: self selectorExpression isNotNil
            then: (self selectorExpression _ analyzeAndEvaluateNodeWith: analyzer)
            else: (AnonymousSymbol basicNewWithNamedSlots: #{
                sourcePosition: self sourcePosition
            })
        ).

        if: hasValidOwner then: {
            let: #analyzedNode with: self shallowCopy.
            let: #implicitArguments with: (self makeImplicitArgumentsFor: ownerProgramEntity _).
            let: #allArguments with: implicitArguments -- self arguments.

            let: #blockClosureNode with: (Reflection AST BlockClosureNode basicNewWithNamedSlots: #{
                arguments: allArguments.
                resultTypeExpression: self resultTypeExpression.
                body: self body _.
                hasLazyBodyAnalysis: true.
            }).
            analyzedNode
                analyzedSelector: selector;
                analyzedOwnerProgramEntity: ownerProgramEntity;
                analyzedBlockClosureNode: (analyzer analyzeNodeIfNeededWithAutoType: blockClosureNode);
                analyzedType: analyzedNode analyzedBlockClosureNode _ analyzedType.
            analyzedNode
        } else: {
            analyzer makeSemanticAnalysisError: "Methods cannot be defined in this context." at: self sourcePosition
        }.
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST MethodDefinitionNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        let: #blockClosure with: (self analyzedBlockClosureNode _ evaluateNodeWith: evaluationEnvironment).
        self analyzedOwnerProgramEntity _ withSelector: self analyzedSelector _ addMethod: blockClosure.
        blockClosure
    }.