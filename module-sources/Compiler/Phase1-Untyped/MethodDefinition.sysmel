__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;
    enterNamespaceNamed: #AST;
    addBindingNamed: #MethodDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST ProgramEntityDefinitionNode publicSlots: #{
        selectorExpression: Reflection AST Node optional.
        resultTypeExpression: Reflection AST Node optional.
        body: Reflection AST Node optional.
        arguments: Reflection AST Node sharedArraySlice.
        visibility: Reflection ProgramEntityVisibility.
        analyzedSelector: Object optional.
        analyzedOwnerProgramEntity: Reflection ProgramEntity optional.
        analyzedBlockClosureNode: Reflection AST Node optional.
    }).

Reflection AST MethodDefinitionNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST MethodDefinitionNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #ownerProgramEntity with: (analyzer environment lexicalScope lookupCurrentProgramEntity).
        let: #hasValidOwner with: (if: ownerProgramEntity isNotNil then: ownerProgramEntity _ canHaveMethods else: false).

        let: #selector with: (if: self selectorExpression isNotNil
            then: (self selectorExpression _ analyzeAndEvaluateNodeWith: analyzer)
            else: (AnonymousSymbol basicNewWithNamedSlots: #{
                sourcePosition: self sourcePosition
            })
        ).

        if: hasValidOwner then: {
            let: #analyzedNode with: self shallowCopy.
            let: #blockClosureNode with: (Reflection AST BlockClosureNode basicNewWithNamedSlots: #{
                arguments: self arguments.
                resultTypeExpression: self resultTypeExpression.
                body: self body _.
                hasLazyBodyAnalysis: true.
            }).
            analyzedNode
                analyzedSelector: selector;
                analyzedOwnerProgramEntity: ownerProgramEntity;
                analyzedBlockClosureNode: (analyzer analyzeNodeIfNeededWithAutoType: blockClosureNode);
                analyzedType: analyzedNode analyzedBlockClosureNode _ analyzedType.
            analyzedNode
        } else: {
            analyzer makeSemanticAnalysisError: "Methods cannot be defined in this context." at: self sourcePosition
        }.
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST MethodDefinitionNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        let: #blockClosure with: (self analyzedBlockClosureNode _ evaluateNodeWith: evaluationEnvironment).
        self analyzedOwnerProgramEntity _ withSelector: self analyzedSelector _ addMethod: blockClosure.
        blockClosure
    }.