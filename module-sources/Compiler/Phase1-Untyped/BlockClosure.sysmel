__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;
    enterNamespaceNamed: #AST;
    addBindingNamed: #BlockClosureNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        arguments: Reflection AST Node sharedArraySlice.
        resultTypeExpression: Reflection AST Node optional.
        body: Reflection AST Node.
        analyzedBody: Reflection AST Node optional.
        analyzedResultTypeExpression: Reflection AST Node optional.
        analyzedResultType: Type optional.
        argumentAnalysisScope: Reflection Semantic LexicalScope optional.
        hasGenericForAllArguments: Boolean.
        hasDependentArguments: Boolean.
        hasCompileTimeDefinedType: Boolean.
        hasLazyBodyAnalysis: Boolean.
    }).

Reflection BlockClosure
    definePublicSlots: #{
        functionType: Function __type__ optional.
        node: Reflection AST BlockClosureNode optional.
        environment: Reflection Semantic EvaluationEnvironment.
    }.

Reflection AST BlockClosureNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST BlockClosureNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedNode with: self shallowCopy.

        let: #argumentAnalysisScope with: analyzer environment lexicalScope makeChildLexicalScope.
        let: #argumentAnalysisEnvironment with: (analyzer environment copyWithLexicalScope: argumentAnalysisScope) copyWithEmptyCleanUpScope.
        let: #hasError with: (Boolean valueBox with: false).

        ## Perform the analysis of the arguments.
        analyzer withEnvironment: argumentAnalysisEnvironment do: { :: Void |
            ## Analyze the arguments.
            analyzedNode arguments: (analyzedNode arguments collect: {:argumentNode :: Reflection AST Node |
                let: #analyzedArgument with: (analyzer analyzeNodeIfNeededWithCurrentExpectedType: argumentNode).
                if: analyzedArgument isErrorNode then: {
                    hasError _: true
                } else: {void}.

                analyzedArgument
            }).

            ## Analyze the result type.
            if: analyzedNode resultTypeExpression isNotNil then: {
                analyzedNode analyzedResultTypeExpression: (analyzer analyzeNodeIfNeeded: analyzedNode resultTypeExpression _ withExpectedType: Type)
            } else: {
                analyzedNode analyzedResultTypeExpression: (LiteralValueNode basicNewWithNamedSlots: #{
                    value: Void.
                    analyzedType: Void __type__
                }).
            }.

            if: analyzedNode analyzedResultTypeExpression _ isErrorNode then: {
                hasError _: true
            } else: {void}.

            void
        }.

        if: hasError _ then: {
            analyzedNode
                argumentAnalysisScope: argumentAnalysisScope;
                analyzedType: CompilationError;
                yourself
        } else: {
            analyzedNode
                argumentAnalysisScope: argumentAnalysisScope;
                analyzeCompileTimeTypeConstraintsWith: argumentAnalysisEnvironment;
                analyzedType: (analyzedNode computeFunctionTypeWith: argumentAnalysisEnvironment).

            if: self hasLazyBodyAnalysis not then: {
                analyzedNode ensureBodyAnalysis.
            } else: { void }.

            analyzedNode
        }.
    };
    withSelector: #ensureBodyAnalysis addMethod: {:(Reflection AST BlockClosureNode)self :: Void |
        if: (if: self hasCompileTimeDefinedType then: self analyzedBody isNil else: false) then: {
            let: #analyzer with: (Reflection Semantic ASTAnalyzer forEnvironment: (Reflection Semantic EvaluationEnvironment forLexicalScope: self argumentAnalysisScope _)).
            self analyzedBody: (analyzer analyzeNodeIfNeeded: self body withExpectedType: self analyzedResultType _).
            void
        } else: { void }
    };
    withSelector: #analyzeCompileTimeTypeConstraintsWith: addMethod: {:(Reflection AST BlockClosureNode)self :(Reflection EvaluationEnvironment)environment :: Void |
        self
            hasGenericForAllArguments: false;
            hasDependentArguments: false;
            hasCompileTimeDefinedType: true.

        self arguments do: {:argumentNode :: Void |
            if: argumentNode isGenericForallArgument then: {
                self hasGenericForAllArguments: true.
            } else: {void}.

            let: #argumentVariable with: argumentNode getArgumentVariable.
            argumentVariable isAnalyzingSignature: false.

            if: argumentVariable hasDependentTypeAccess then: {
                self hasDependentArguments: true
            } else: { void }.

            if: (argumentNode analyzedTypeExpression _ isCompileTimeDirectlyEvaluableWith: environment) then: {
                argumentNode analyzedTypeExpression: (argumentNode analyzedTypeExpression _ optimizeViaCompileTimeEvaluationWith: environment)
            } else: {
                self hasCompileTimeDefinedType: false
            }.

            void
        }.

        if: (self analyzedResultTypeExpression _ isCompileTimeDirectlyEvaluableWith: environment) then: {
            self analyzedResultTypeExpression: (self analyzedResultTypeExpression _ optimizeViaCompileTimeEvaluationWith: environment)
        } else: {
            self hasCompileTimeDefinedType: false
        }.

        void
    };
    withSelector: #computeFunctionTypeWith: addMethod: {:(Reflection AST BlockClosureNode)self :(Reflection EvaluationEnvironment)environment :: Type |
        if: self hasCompileTimeDefinedType then: {
            let: #argumentTypes with: (self arguments collect: {:argumentNode :: Type |
                argumentNode analyzedTypeExpression _ evaluateNodeWith: environment
            }).

            let: #resultType with: (self analyzedResultTypeExpression _ evaluateNodeWith: environment).
            self analyzedResultType: resultType.
            Function newSimpleFunctionTypeWithArguments: argumentTypes resultType: resultType
        } else: {
            Function newDependentFunctionTypeWithEnvironment: environment arguments: self arguments resultType: self analyzedResultTypeExpression.
        }.
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST BlockClosureNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        let: #blockClosure with: (Reflection BlockClosure basicNewWithNamedSlots: #{
            functionType: self analyzedType _.
            node: self.
            environment: evaluationEnvironment.
        }).

        self analyzedType _ newWithImplementation: blockClosure
    };
    withSelector: #evaluateWithEnvironment:arguments: addMethod: {:(Reflection AST BlockClosureNode)self :(Reflection Semantic EvaluationEnvironment)environment :(AnyValue arraySlice)arguments :: AnyValue |
        self ensureBodyAnalysis.

        if: self analyzedBody isNotNil then: {
            let: #evaluationScope with: environment lexicalScope makeChildLexicalScope.
            let: #evaluationEnvironment with: (environment copyWithLexicalScope: evaluationScope) copyWithEmptyCleanUpScope.
            let: #currentArgumentIndex with: (Size valueBox with: 0sz).

            self arguments do: {:(Reflection AST Node)argumentNode :: Void |
                let: #argumentVariable with: argumentNode getArgumentVariable.

                if: argumentNode isGenericForallArgument then: {
                    void.
                } else: {
                    if: currentArgumentIndex _ < arguments size then: {
                        let: #argumentValue with: (arguments basicAt: currentArgumentIndex _).
                        evaluationScope setSymbol: argumentVariable immutableValue: argumentValue.
                        currentArgumentIndex _: currentArgumentIndex _ + 1sz
                    } else: {
                        __BootstrapCompiler__ error: "Missing arguments required for function evaluation."
                    }
                }.
                void
            }.

            if: currentArgumentIndex _ < arguments size then: {
                __BootstrapCompiler__ error: "Excessive arguments passed to function evaluation."
            } else: {
                void
            }.

            self analyzedBody _ evaluateNodeWith: evaluationEnvironment
        } else: {
            __BootstrapCompiler__ print: "TODO: BlockClosureNode evaluateWithEnvironment:arguments: handle generic case generic case and or dependent case.".
            __BootstrapCompiler__ print: arguments.
            __BootstrapCompiler__ primitiveFailed
        }.
    }.

Reflection BlockClosure
    withSelector: #run:with:in: addMethod: {:(Reflection BlockClosure)self :(AnyValue)selector :(AnyValue arraySlice)arguments :(AnyValue)receiver :: AnyValue |
        __BootstrapCompiler__ print: "TODO: BlockClosure evaluateWithArguments:".
        __BootstrapCompiler__ print: selector.
        __BootstrapCompiler__ print: arguments.
        __BootstrapCompiler__ print: receiver.
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #evaluateWithArguments: addMethod: {:(Reflection BlockClosure)self :(AnyValue arraySlice)arguments :: AnyValue |
        self node _ evaluateWithEnvironment: self environment arguments: arguments
    };
    withSelector: #hasMethodFlag: addMethod: {:(Reflection BlockClosure)self :(Symbol)flag :: Boolean |
        false
    }.