
## Semantic analysis types.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;
    enterNamespaceNamed: #Semantic;
    addBindingNamed: #SymbolBinding with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBindingNamed: #IdentifierLookupScope with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBindingNamed: #LexicalScope with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic IdentifierLookupScope publicSlots: #{
    });
    addBindingNamed: #CleanUpScope with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{}).

Reflection Semantic IdentifierLookupScope definePublicSlots: #{
    parent: Reflection Semantic IdentifierLookupScope optional
}.

Reflection Semantic CleanUpScope definePublicSlots: #{
    parent: Reflection Semantic CleanUpScope optional
}.

## The AST nodes.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;

    addBindingNamed: #SourceStringCollection with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection SourceCollection publicSlots: #{
        sourceString: String.
        name: String.
    });
    addBindingNamed: #SourceStringPosition with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection SourcePosition publicSlots: #{
        sourceCollection: Reflection SourceCollection.
        startPosition: Size.
        endPosition: Size.
        startLine: Size.
        startColumn: Size.
        endLine: Size.
        endColumn: Size.
    });
    addBindingNamed: #EmptySourcePosition with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection SourcePosition publicSlots: #{});

    enterNamespaceNamed: #AST;

    addBindingNamed: #Node with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{
        sourcePosition: Reflection SourcePosition.
        analyzedType: Type optional
    });
    addBindingNamed: #ArgumentDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        name: Reflection AST Node.
        type: Reflection AST Node.
    });
    addBindingNamed: #BlockClosureNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        arguments: Reflection AST Node sharedArraySlice.
        body: Reflection AST Node.
    });
    addBindingNamed: #ChainedMessageNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        selector: Reflection AST Node.
        arguments: Reflection AST Node sharedArraySlice
    });
    addBindingNamed: #CleanUpScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        body: Reflection AST Node.
        cleanUpAction: Reflection AST Node optional.
        analysisScope: Reflection Semantic CleanUpScope optional.
    });
    addBindingNamed: #LexicalScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        body: Reflection AST Node.
        analysisScope: Reflection Semantic LexicalScope optional.
    });
    addBindingNamed: #LiteralValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        value: AnyValue
    });
    addBindingNamed: #IdentifierReferenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        value: Object.
        binding: Reflection Semantic SymbolBinding optional.
    });

    addBindingNamed: #MakeAssociationNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        key: Reflection AST Node.
        value: Reflection AST Node.
    });
    addBindingNamed: #MakeTupleNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        elements: Reflection AST Node sharedArraySlice.
    });
    addBindingNamed: #MakeDictionaryNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        elements: Reflection AST Node sharedArraySlice.
    });

    addBindingNamed: #MessageSendNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        receiver: Reflection AST Node optional.
        selector: Reflection AST Node.
        arguments: Reflection AST Node sharedArraySlice.
        boundMethod: Object optional.
        usesDynamicDispatch: Boolean.
    });
    addBindingNamed: #MessageChainNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        receiver: Reflection AST Node.
        chainedMessages: Reflection AST Node sharedArraySlice
    });
    addBindingNamed: #SequenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        expressions: Reflection AST Node sharedArraySlice.
        pragmas: Reflection AST Node sharedArraySlice.
    });

    addBindingNamed: #SpliceNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        expression: Reflection AST Node.
    });
    addBindingNamed: #QuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        expression: Reflection AST Node.
    });
    addBindingNamed: #QuasiQuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        expression: Reflection AST Node.
    });
    addBindingNamed: #QuasiUnquoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        expression: Reflection AST Node.
    });

    addBindingNamed: #ErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        message: String
    });
    addBindingNamed: #ParseErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST ErrorNode publicSlots: #{});
    addBindingNamed: #SemanticErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST ErrorNode publicSlots: #{
        innerNode: Reflection AST Node optional
    });

    addBindingNamed: #IfTrueIfFalseNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        condition: Reflection AST Node.
        trueExpression: Reflection AST Node optional.
        falseExpression: Reflection AST Node optional.
    });
    addBindingNamed: #WhileDoContinueNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        condition: Reflection AST Node.
        bodyExpression: Reflection AST Node optional.
        continueExpression: Reflection AST Node optional.
    });


    ## Basic type conversion nodes
    addBindingNamed: #TypeConversionNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        expression: Reflection AST Node.
    });
    addBindingNamed: #ValueAsVoidNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST TypeConversionNode publicSlots: #{});
    addBindingNamed: #WrapValueInSumTypeNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST TypeConversionNode publicSlots: #{
        typeSelector: Size.
    });
    addBindingNamed: #WrapAnyValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST TypeConversionNode publicSlots: #{});
    addBindingNamed: #UnwrapAnyValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST TypeConversionNode publicSlots: #{});
    addBindingNamed: #UpcastConversionNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST TypeConversionNode publicSlots: #{});

    ## Stablish the basic ast node mapping that is required for converting a parse tree onto the actual AST object.
    setParseTreeASTMaping: #{
        SourceCollection: Reflection SourceCollection.
        SourcePosition: Reflection SourcePosition.
        SourceStringCollection: Reflection SourceStringCollection.
        SourceStringPosition: Reflection SourceStringPosition.
        EmptySourcePosition: Reflection EmptySourcePosition.

        Node: Reflection AST Node.
        NodeArrayList: Reflection AST Node arrayList.
        NodeSharedArraySlice: Reflection AST Node sharedArraySlice.

        ArgumentDefinitionNode: Reflection AST ArgumentDefinitionNode.
        BlockClosureNode: Reflection AST BlockClosureNode.
        ChainedMessageNode: Reflection AST ChainedMessageNode.
        CleanUpScopeNode: Reflection AST CleanUpScopeNode.
        IdentifierReferenceNode: Reflection AST IdentifierReferenceNode.
        LexicalScopeNode: Reflection AST LexicalScopeNode.
        LiteralValueNode: Reflection AST LiteralValueNode.
        MakeAssociationNode: Reflection AST MakeAssociationNode.
        MakeDictionaryNode: Reflection AST MakeDictionaryNode.
        MakeTupleNode: Reflection AST MakeTupleNode.
        MessageSendNode: Reflection AST MessageSendNode.
        MessageChainNode: Reflection AST MessageChainNode.
        QuoteNode: Reflection AST QuoteNode.
        QuasiQuoteNode: Reflection AST QuasiQuoteNode.
        QuasiUnquoteNode: Reflection AST QuasiUnquoteNode.
        SequenceNode: Reflection AST SequenceNode.
        SpliceNode: Reflection AST SpliceNode.

        ErrorNode: Reflection AST ErrorNode.
        ParseErrorNode: Reflection AST ParseErrorNode.
        SemanticErrorNode: Reflection AST SemanticErrorNode.
    }.

## Semantic analysis types.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;
    enterNamespaceNamed: #Semantic;

    addBindingNamed: #AnonymousSymbol with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{
        sourcePosition: Reflection SourcePosition optional
    });
    addBindingNamed: #MessageChainReceiverAnonymousSymbol with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic AnonymousSymbol publicSlots: #{});

    addBindingNamed: #FunctionSignatureAnalyzer with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBindingNamed: #SymbolValueBinding with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic SymbolBinding publicSlots: #{
        name: Object.
        value: AnyValue
    });
    addBindingNamed: #ForAllPlaceholderBinding with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic SymbolBinding publicSlots: #{
        name: Object.
        value: AnyValue.
        expectedType: Type.
    });
    addBindingNamed: #TypeOrForAllPlaceholder with: (__TypeBuilder__ newSumTypeWith: (Type, Reflection Semantic ForAllPlaceholderBinding));
    addBindingNamed: #NamespaceScope with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic LexicalScope publicSlots: #{});
    addBindingNamed: #ScriptEvaluationScope with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic LexicalScope publicSlots: #{});
    addBindingNamed: #EvaluationEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{
        lexicalScope: Reflection Semantic LexicalScope.
        cleanUpScope: Reflection Semantic CleanUpScope.
    });
    addBindingNamed: #TypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{});
    addBindingNamed: #ExpectedTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic TypeInferenceEnvironment publicSlots: #{
        expectedType: Type
    });
    addBindingNamed: #AutoTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic TypeInferenceEnvironment publicSlots: #{});
    addBindingNamed: #DirectAutoTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic TypeInferenceEnvironment publicSlots: #{});
    addBindingNamed: #ReferenceAutoTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection Semantic TypeInferenceEnvironment publicSlots: #{});
    addBindingNamed: #ASTAnalyzer with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{
        environment: Reflection Semantic EvaluationEnvironment.
        typeInferenceEnvironment: Reflection Semantic TypeInferenceEnvironment.
    });
    setSemanticAnalysisMapping: #{
        FunctionSignatureAnalyzer: Reflection Semantic FunctionSignatureAnalyzer.
        SymbolBinding: Reflection Semantic SymbolBinding.
        SymbolValueBinding: Reflection Semantic SymbolValueBinding.
        IdentifierLookupScope: Reflection Semantic IdentifierLookupScope.
        LexicalScope: Reflection Semantic LexicalScope.
        NamespaceScope: Reflection Semantic NamespaceScope.
        ScriptEvaluationScope: Reflection Semantic ScriptEvaluationScope.
        EvaluationEnvironment: Reflection Semantic EvaluationEnvironment.
        ASTAnalyzer: Reflection Semantic ASTAnalyzer.
    }.

## Macro invocation context.
__BootstrapCompiler__
    enterTopLevelNamespace;
    addBindingNamed: #MacroInvocationContext with: (__TypeBuilder__ newGCClassWithSuperclass: Object publicSlots: #{
        sourcePosition: Reflection SourcePosition.
        selfNode: Reflection AST Node optional.
        selfType: Type.
        astAnalyzer: Reflection Semantic ASTAnalyzer.
    }).

Reflection AST Node
    withSelector: #analyzeNodeIfNeededWith: addMethod: {:(Reflection AST Node)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self analyzedType isNil then: {
            self analyzeNodeWith: analyzer
        } else: {
            self
        }
    };
    withSelector: #analyzeAndEvaluateNodeWith: addMethod: {:(Reflection AST Node)self :(Reflection Semantic ASTAnalyzer)analyzer :: AnyValue |
        (self analyzeNodeIfNeededWith: analyzer) evaluateNodeWith: analyzer environment
    };
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST Node)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #asCollapsedNodeWith: addMethod: {:(Reflection AST Node)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST Node)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #isLiteralValueNode addMethod: {:(Reflection AST Node)self :: Boolean |
        false
    };
    withSelector: #evaluateLiteralValue addMethod: {:(Reflection AST Node)self :: AnyValue |
        __BootstrapCompiler__ error: "Not a literal value node."
    };
    withSelector: #analyzeAndEvaluateNodeWithScriptEvaluationScope: addMethod: {:(Reflection AST Node)self :(Reflection Semantic ScriptEvaluationScope)scope :: AnyValue |
        self analyzeAndEvaluateNodeWith: (Reflection Semantic ASTAnalyzer forScriptEvaluationScope: scope)
    }.

Reflection SourceStringCollection
    withSelector: #printString addMethod: {:(Reflection AST SourceStringCollection)self :: String |
        self name
    }.

Reflection SourceStringPosition
    withSelector: #printString addMethod: {:(Reflection AST SourceStringCollection)self :: String |
        "{0}:{1}.{2}-{3}.{4}" format: (self sourceCollection printString,
            self startLine printString, self startColumn printString,
            self endLine printString, self endColumn printString,
        )
    }.

Reflection AST LiteralValueNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST LiteralValueNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self shallowCopy
            analyzedType: self value __type__;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST LiteralValueNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self value
    };
    withSelector: #isLiteralValueNode addMethod: {:(Reflection AST LiteralValueNode)self :: Boolean |
        true
    };
    withSelector: #evaluateLiteralValue addMethod: {:(Reflection AST LiteralValueNode)self :: AnyValue |
        self value
    }.

Reflection AST CleanUpScopeNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST CleanUpScopeNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #cleanUpScope with: (analyzer environment cleanUpScope makeChildCleanUpScope).
        let: #childEnvironment with: (analyzer environment copyWithCleanUpScope: cleanUpScope).

        let: #analyzedBody with: (analyzer analyzeNodeIfNeeded: self body withEnvironment: childEnvironment).
        let: #analyzedNode with: self shallowCopy.

        if: analyzedNode cleanUpAction isNotNil then: {
            analyzedNode cleanUpAction: (analyzer analyzeNodeIfNeeded: analyzedNode cleanUpAction _ withExpectedType: Void)
        } else: {
            void
        }.

        analyzedNode
            body: analyzedBody;
            analyzedType: analyzedBody analyzedType _;
            analysisScope: cleanUpScope;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        let: #result with: (self body evaluateNodeWith: evaluationEnvironment).

        if: self cleanUpAction isNotNil then: {
            self cleanUpAction _ evaluateNodeWith: evaluationEnvironment
        } else: {
            void
        }.

        result
    }.

Reflection AST LexicalScopeNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST LexicalScopeNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #lexicalScope with: (analyzer environment lexicalScope makeChildLexicalScope).
        let: #childEnvironment with: (analyzer environment copyWithLexicalScope: lexicalScope).

        let: #analyzedBody with: (analyzer analyzeNodeIfNeeded: self body withEnvironment: childEnvironment).
        self shallowCopy
            body: analyzedBody;
            analysisScope: lexicalScope;
            analyzedType: analyzedBody analyzedType _;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self body evaluateNodeWith: evaluationEnvironment
    }.

Reflection AST SequenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST SequenceNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedPragmas with: (self pragmas collect: {:(Reflection AST Node)node :: Reflection AST Node |
                analyzer analyzedNodeIfNeeded: node withExpectedType: Pragma
        }).
        let: #analyzedExpressions with: (self expressions collectWithIndex: {:(Reflection AST Node)node :(Size)index :: Reflection AST Node |
                if: index + 1sz < self expressions size then: {
                    analyzer analyzeNodeIfNeeded: node withExpectedType: Void.
                } else: {
                    analyzer analyzeNodeIfNeededWithCurrentExpectedType: node
                }
        }).

        self shallowCopy
            pragmas: analyzedPragmas;
            expressions: analyzedExpressions;
            analyzedType: (if: analyzedExpressions isEmpty then: Void else: analyzedExpressions last analyzedType _);
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        let: #result with: (AnyValue valueBox with: void).
        
        self expressions do: {:(Reflection AST Node)node |
            result _: (node evaluateNodeWith: evaluationEnvironment).
            void
        }.

        result _
    }.

Reflection AST IdentifierReferenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST IdentifierReferenceNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #binding with: (analyzer environment lexicalScope lookupSymbolRecursively: self value).
        
        if: binding isNil then: {
            analyzer makeSemanticAnalysisError: ("Failed to binding for symbol {0}." format: (self value printString, )) at: self sourcePosition
        } else: {
            binding _ analyzeIdentifierReferenceNode: self with: analyzer
        }
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self binding evaluateBindingWithEnvironment: evaluationEnvironment
    }.

Reflection AST MessageSendNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST MessageSendNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedSelector with: (analyzer analyzeNodeIfNeededWithAutoType: self selector).
        if: self receiver isNil then: {
            if: analyzedSelector isLiteralValueNode then: {
                let: #selectorValue with: (analyzedSelector evaluateNodeWith: analyzer).
                let: #binding with: (analyzer environment lexicalScope lookupSymbolRecursively: selectorValue).

                if: binding isNil then: {
                    analyzer makeSemanticAnalysisError: ("Failed to binding for selector {0}." format: (selectorValue printString, )) at: self sourcePosition
                } else: {
                    binding _ analyzeMessageSendNode: (self shallowCopy
                        selector: analyzedSelector;
                        yourself) with: analyzer
                }
            } else: {
                analyzer makeSemanticAnalysisError: ("Message  {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
            }
        } else: {
            let: #analyzedReceiver with: (analyzer analyzeNodeIfNeededWithDirectAutoType: self receiver _ ).
            analyzedReceiver analyzedType _ analyzeMessageSendNode: (self shallowCopy
                receiver: analyzedReceiver;
                selector: analyzedSelector;
                yourself) with: analyzer
        }.
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST MessageSendNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: self receiver isNil then: {
            self boundMethod run: (self selector evaluateNodeWith: evaluationEnvironment) with: (self arguments collect: {:(Reflection AST Node)arg :: AnyValue |
                arg evaluateNodeWith: evaluationEnvironment
            }) in: nil
        } else: {
            let: #receiver with: (self receiver _ evaluateNodeWith: evaluationEnvironment).
            let: #selector with: (self selector evaluateNodeWith: evaluationEnvironment).
            let: #arguments with: (self arguments collect: {:(Reflection AST Node)arg :: AnyValue |
                    arg evaluateNodeWith: evaluationEnvironment
            }).

            if: self usesDynamicDispatch | self boundMethod isNil then: {
                receiver perform: selector withArguments: arguments
            } else: {
                self boundMethod _ run: selector with: arguments in: receiver
            }
        }
    }.

Reflection AST ChainedMessageNode
    withSelector: #asMessageSendNodeWithReceiver: addMethod: {:(Reflection AST ChainedMessageNode)self :(Reflection AST Node)receiver :: Reflection AST Node |
        Reflection AST MessageSendNode basicNewWithNamedSlots: #{
            sourcePosition: self sourcePosition.
            receiver: receiver.
            selector: self selector.
            arguments: self arguments
        }
    }.

Reflection AST MessageChainNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST SequenceNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #receiverSymbol with: (Reflection Semantic MessageChainReceiverAnonymousSymbol basicNewWithNamedSlots: #{
            sourcePosition: self sourcePosition
        }).
        let: #receiverVariable with: (Reflection AST LocalVariableDefinitionNode basicNewWithNamedSlots: #{
            sourcePosition: self sourcePosition.
            nameExpression: (Reflection AST LiteralValueNode basicNewWithNamedSlots: #{
                sourcePosition: self sourcePosition.
                value: receiverSymbol
            }).
            initialValueExpression: self receiver.
            hasDirectTypeInference: true.
        }).

        let: #receiverIdentifier with: (Reflection AST IdentifierReferenceNode basicNewWithNamedSlots: #{
            sourcePosition: self sourcePosition.
            value: receiverSymbol.
        }).

        let: #messageSequenceNode with: (Reflection AST SequenceNode basicNewWithNamedSlots: #{
            sourcePosition: self sourcePosition.
            expressions: (self chainedMessages collect: {:(Reflection AST Node)node :: Reflection AST Node |
                node asMessageSendNodeWithReceiver: receiverIdentifier
            })
        }).

        let: #sequenceNode with: (Reflection AST SequenceNode basicNewWithNamedSlots: #{
            sourcePosition: self sourcePosition.
            expressions: (Reflection AST Node sharedArraySlice with: receiverVariable with: messageSequenceNode)
        }).

        analyzer analyzeNodeIfNeededWithCurrentExpectedType: sequenceNode
    }.

Reflection AST ParseErrorNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST ParseErrorNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self shallowCopy
            analyzedType: CompilationError;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ parseError: self message at: self sourcePosition
    }.

Reflection AST SemanticErrorNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST SemanticErrorNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self shallowCopy
            analyzedType: CompilationError;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST SemanticErrorNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: self innerNode isNotNil then: {
            self innerNode evaluateNodeWith: evaluationEnvironment
        } else: {void}.

        __BootstrapCompiler__ semanticAnalysisError: self message at: self sourcePosition
    }.

Reflection AST IfTrueIfFalseNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST IfTrueIfFalseNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedNode with: self shallowCopy.

        analyzedNode condition: (analyzer analyzeNodeIfNeeded: self condition withExpectedType: Boolean).
        ## Initial per-branch analysis
        if: analyzedNode trueExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode trueExpression: (analyzer analyzeNodeIfNeededWithCurrentExpectedType: analyzedNode trueExpression _)
        }.

        if: analyzedNode falseExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode falseExpression:  (analyzer analyzeNodeIfNeededWithCurrentExpectedType: analyzedNode falseExpression _)
        }.

        ## Compute the result type.
        if: analyzedNode falseExpression isNil | analyzedNode trueExpression isNil then: {
            analyzedNode analyzedType: Void
        } else: {
            analyzedNode analyzedType: (analyzer computeBranchResultTypeOf: analyzedNode falseExpression _ analyzedType _ with: analyzedNode trueExpression _ analyzedType _)
        }.

        if: analyzedNode trueExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode trueExpression: (analyzer analyzeNodeIfNeeded: analyzedNode trueExpression _ withExpectedType: analyzedNode analyzedType _)
        }.

        if: analyzedNode falseExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode falseExpression: (analyzer analyzeNodeIfNeeded: analyzedNode falseExpression _ withExpectedType: analyzedNode analyzedType _)
        }.

        analyzedNode
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST IfTrueIfFalseNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: (self condition evaluateNodeWith: evaluationEnvironment) then: {
            if: self trueExpression isNil then: {
                void
            } else: {
                self trueExpression _ evaluateNodeWith: evaluationEnvironment
            }
        } else: {
            if: self falseExpression isNil then: {
                void
            } else: {
                self falseExpression _ evaluateNodeWith: evaluationEnvironment
            }
        }
    }.

Reflection AST WhileDoContinueNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST WhileDoContinueNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedNode with: self shallowCopy.

        analyzedNode
            condition: (analyzer analyzeNodeIfNeeded: self condition withExpectedType: Boolean);
            analyzedType: Void.

        ## Body expression.
        if: analyzedNode bodyExpression isNil then: {
            ## Nothing is required here
        } else: {
            analyzedNode bodyExpression: (analyzer analyzeNodeIfNeeded: analyzedNode bodyExpression _ withExpectedType: Void)
        }.

        ## Continue expression.
        if: analyzedNode continueExpression isNil then: {
            ## Nothing is required here
        } else: {
            analyzedNode continueExpression: (analyzer analyzeNodeIfNeeded: analyzedNode continueExpression _ withExpectedType: Void)
        }.

        analyzedNode
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST WhileDoContinueNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        while: (self condition evaluateNodeWith: evaluationEnvironment) do: {
            if: self bodyExpression isNil then: {
                void
            } else: {
                self bodyExpression _ evaluateNodeWith: evaluationEnvironment
            }
        } continueWith: {
            if: self continueExpression isNil then: {
                void
            } else: {
                self continueExpression _ evaluateNodeWith: evaluationEnvironment
            }
        }
    }.

Reflection AST ValueAsVoidNode
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST ValueAsVoidNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self expression evaluateNodeWith: evaluationEnvironment.
        void
    }.

Reflection AST WrapValueInSumTypeNode
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST WrapValueInSumTypeNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self analyzedType _ basicNew: (self expression evaluateNodeWith: evaluationEnvironment) typeSelector: self typeSelector
    }.

Reflection AST UpcastConversionNode
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST WrapValueInSumTypeNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        ## This is a nop in the evaluator.
        self expression evaluateNodeWith: evaluationEnvironment
    }.

Reflection AST WrapAnyValueNode
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST WrapValueInSumTypeNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        ## This is a nop in the evaluator.
        self expression evaluateNodeWith: evaluationEnvironment
    }.
Reflection AST UnwrapAnyValueNode
    withSelector: #evaluateNodeWith: addMethod: {:(Reflection AST WrapValueInSumTypeNode)self :(Reflection Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        ## This is a nop in the evaluator.
        self expression evaluateNodeWith: evaluationEnvironment
    }.

Reflection Semantic IdentifierLookupScope
    withSelector: #lookupSymbol: addMethod: {:(Reflection Semantic IdentifierLookupScope)self :(Object)symbol :: Reflection Semantic SymbolBinding optional |
        <primitive: #"identifierLookupScope.lookupSymbol">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSymbolRecursively: addMethod: {:(Reflection Semantic IdentifierLookupScope)self :(Object)symbol :: Reflection Semantic SymbolBinding optional |
        <primitive: #"identifierLookupScope.lookupSymbolRecursively">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #makeChildLexicalScope addMethod: {:(Reflection Semantic IdentifierLookupScope)self :: Reflection Semantic LexicalScope |
        <primitive: #"identifierLookupScope.makeChildLexicalScope">
        __BootstrapCompiler__ primitiveFailed
    }.

Reflection Semantic LexicalScope
    withSelector: #setSymbol:binding: addMethod: {:(Reflection Semantic LexicalScope)self :(Object)symbol :(Reflection Semantic SymbolBinding)binding :: Void |
        <primitive: #"lexicalScope.setSymbolBinding">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #setSymbol:immutableValue: addMethod: {:(Reflection Semantic LexicalScope)self :(Object)symbol :(AnyValue)immutableValue :: Void |
        <primitive: #"lexicalScope.setSymbolImmutableValue">
        __BootstrapCompiler__ primitiveFailed
    }.

Reflection Semantic CleanUpScope
    withSelector: #makeChildCleanUpScope addMethod: {:(Reflection Semantic CleanUpScope)self :: Reflection Semantic CleanUpScope |
        Reflection Semantic CleanUpScope basicNewWithNamedSlots: #{
            parent: self
        }
    }.

Reflection Semantic SymbolBinding
    withSelector: #evaluateBindingWithEnvironment: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)environment :: AnyValue |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(Reflection Semantic SymbolBinding)self :(Reflection AST IdentifierReferenceNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        __BootstrapCompiler__ subclassResponsibility
    }.

Reflection Semantic SymbolValueBinding
    withSelector: #evaluateBindingWithEnvironment: addMethod: {:(Type)self :(Reflection Semantic EvaluationEnvironment)environment :: AnyValue |
        self value
    };
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self value __type__ analyzeMessageSendNode: node with: analyzer valueBinding: self
    };
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(Reflection Semantic SymbolValueBinding)self :(Reflection AST IdentifierReferenceNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self value __type__ analyzeIdentifierReferenceNode: node with: analyzer valueBinding: self
    }.

Reflection Semantic EvaluationEnvironment __type__
    withSelector: #default addMethod: {:(Reflection Semantic EvaluationEnvironment __type__)self :: self |
        self basicNewWithNamedSlots: #{
            lexicalScope: __BootstrapCompiler__ getTopLevelEnvironment makeChildLexicalScope.
            cleanUpScope: Reflection Semantic CleanUpScope basicNew.
        }
    };
    withSelector: #forScriptEvaluationScope: addMethod: {:(Reflection Semantic EvaluationEnvironment __type__)self :(Reflection Semantic ScriptEvaluationScope)scope :: self |
        self basicNewWithNamedSlots: #{
            lexicalScope: scope.
            cleanUpScope: Reflection Semantic CleanUpScope basicNew.
        }
    }.

Reflection Semantic EvaluationEnvironment
    withSelector: #copyWithLexicalScope: addMethod: {:(Reflection Semantic EvaluationEnvironment)self :(Reflection Semantic LexicalScope)scope :: Reflection Semantic EvaluationEnvironment |
        self shallowCopy
            lexicalScope: scope;
            yourself
    };
    withSelector: #copyWithCleanUpScope: addMethod: {:(Reflection Semantic EvaluationEnvironment)self :(Reflection Semantic CleanUpScope)scope :: Reflection Semantic EvaluationEnvironment |
        self shallowCopy
            cleanUpScope: scope;
            yourself
    }.

Reflection Semantic ASTAnalyzer __type__
    withSelector: #forEnvironment: addMethod: {:(Reflection Semantic ASTAnalyzer __type__)self :(Reflection Semantic EvaluationEnvironment)environment :: self |
        self basicNewWithNamedSlots: #{
            environment: environment.
            typeInferenceEnvironment: Reflection Semantic AutoTypeInferenceEnvironment basicNew.
        }
    };
    withSelector: #forScriptEvaluationScope: addMethod: {:(Reflection Semantic ASTAnalyzer __type__)self :(Reflection Semantic ScriptEvaluationScope)scope :: self |
        self forEnvironment: (Reflection Semantic EvaluationEnvironment forScriptEvaluationScope: scope)
    };
    withSelector: #forDefaultEnvironment addMethod: {:(Reflection Semantic ASTAnalyzer __type__)self :: self |
        self forEnvironment: Reflection Semantic EvaluationEnvironment default
    }.

Reflection Semantic TypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(Reflection Semantic TypeInferenceEnvironment)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer |
        __BootstrapCompiler__ subclassResponsibility
    }.

Reflection Semantic DirectAutoTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(Reflection Semantic TypeInferenceEnvironment)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        node
    }.

Reflection Semantic ReferenceAutoTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(Reflection Semantic TypeInferenceEnvironment)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #collapsedNode with: (node asCollapsedNodeWith: analyzer).
        analyzer addImplicitCoercionTo: collapsedNode analyzedType _ asReferenceDecayedType node: collapsedNode
    }.

Reflection Semantic AutoTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(Reflection Semantic TypeInferenceEnvironment)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node  |
        let: #collapsedNode with: (node asCollapsedNodeWith: analyzer).
        analyzer addImplicitCoercionTo: collapsedNode analyzedType _ asDecayedType node: collapsedNode
    }.

Reflection Semantic ExpectedTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(Reflection Semantic TypeInferenceEnvironment)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node  |
        analyzer addImplicitCoercionTo: self expectedType node: (node asCollapsedNodeWith: analyzer).
    }.

Reflection Semantic ASTAnalyzer
    withSelector: #makeSemanticAnalysisError:at: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(String)errorMessage :(Reflection SourcePosition)sourcePosition :: Reflection AST SemanticErrorNode |
        Reflection AST SemanticErrorNode basicNewWithNamedSlots: #{
            analyzedType: CompilationError.
            sourcePosition: sourcePosition.
            message: errorMessage.
        }.
    };
    withSelector: #makeSemanticAnalysisError:atNode: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(String)errorMessage :(Reflection AST Node)node :: Reflection AST SemanticErrorNode |
        Reflection AST SemanticErrorNode basicNewWithNamedSlots: #{
            analyzedType: (if: node analyzedType isNil then: CompilationError else: node analyzedType _).
            sourcePosition: node sourcePosition.
            message: errorMessage.
            innerNode: node
        }.
    };

    withSelector: #makeMacroInvocationContextForIdentifierReferenceNode: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST IdentifierReferenceNode)node :: MacroInvocationContext |
        MacroInvocationContext basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            selfType: Void.
            astAnalyzer: self
        }
    };
    withSelector: #makeMacroInvocationContextForMessageSendNode: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST MessageSendNode)node :: MacroInvocationContext |
        MacroInvocationContext basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            selfNode: node receiver.
            selfType: (if: node receiver isNil then: {
                Void
            } else: {
                if: node receiver _ analyzedType isNil then: Void then: node receiver _ analyzedType
            }).
            astAnalyzer: self
        }
    };

    withSelector: #analyzeNodeIfNeededWithDirectAutoType: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :: Reflection AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: Reflection Semantic DirectAutoTypeInferenceEnvironment basicNew
    };
    withSelector: #analyzeNodeIfNeededWithReferenceAutoType: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :: Reflection AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: Reflection Semantic ReferenceAutoTypeInferenceEnvironment basicNew
    };
    withSelector: #analyzeNodeIfNeededWithAutoType: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :: Reflection AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: Reflection Semantic AutoTypeInferenceEnvironment basicNew
    };
    withSelector: #analyzeNodeIfNeeded:withEnvironment: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :(Reflection Semantic EvaluationEnvironment)environment :: Reflection AST Node |
        let: #oldEnvironment with: self environment.
        self environment: environment.

        let: #analyzedNode with: (self analyzeNodeIfNeededWithCurrentExpectedType: node).
        self environment: oldEnvironment.

        analyzedNode
    };
    withSelector: #analyzeNodeIfNeeded:withTypeInferenceEnvironment: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :(Reflection Semantic TypeInferenceEnvironment)typeInferenceEnvironment :: Reflection AST Node |
        let: #oldTypeInferenceEnvironment with: (self typeInferenceEnvironment).
        self typeInferenceEnvironment: typeInferenceEnvironment.

        let: #analyzedNode with: (self analyzeNodeIfNeededWithCurrentExpectedType: node).
        self typeInferenceEnvironment: oldTypeInferenceEnvironment.
        analyzedNode
    };
    
    withSelector: #analyzeNodeIfNeeded:withExpectedType: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :(Type)expectedType :: Reflection AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: (Reflection Semantic ExpectedTypeInferenceEnvironment basicNewWithNamedSlots: #{
            expectedType: expectedType
        })
    };
    withSelector: #analyzeNodeIfNeededWithCurrentExpectedType: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Reflection AST Node)node :: Reflection AST Node |
        self typeInferenceEnvironment solveAnalyzedNodeType: (node analyzeNodeIfNeededWith: self) with: self
    };
    withSelector: #computeBranchResultTypeOf:with: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Type)leftType :(Type)rightType :: Type |
        if: leftType == rightType then: {
            leftType
        } else: {
            Void
        }
    };
    withSelector: #addImplicitCoercionTo:node: addMethod: {:(Reflection Semantic ASTAnalyzer)self :(Type)targetType :(Reflection AST Node)node :: Reflection AST Node |
        node analyzedType _ addImplicitCoercionToNode: node targetType: targetType with: self
    }.

Type
    withSelector: #asString addMethod: {:(Type)self :: String |
        <pure>
        <primitive: #"type.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Type)self :: String |
        <pure>
        <primitive: #"type.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :(AnyValue)selector :: AnyValue |
        <primitive: #"type.lookupSelector">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self analyzeNormalMessageSendNode: node with: analyzer
    };
    withSelector: #analyzeNormalMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: node selector isLiteralValueNode then: {
            let: #selector with: (node selector evaluateLiteralValue).
            let: #method with: (self lookupSelector: selector).

            if: method isNil then: {
                self analyzeUnboundMessageSendNode: node with: analyzer
            } else: {
                method analyzeMessageSendNode: node with: analyzer
            }
        } else: {
            self analyzeUnboundOrDynamicMessageSendNode: node with: analyzer
        }
    };
    withSelector: #analyzeUnboundMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self analyzeUnboundOrDynamicMessageSendNode: node with: analyzer
    };
    withSelector: #analyzeUnboundOrDynamicMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self hasAnyValueFlag then: {
            self analyzeDynamicMessageSendNode: node with: analyzerx
        } else: {
            __BootstrapCompiler__ print: "Selector node".
            __BootstrapCompiler__ print: node selector.
            __BootstrapCompiler__ print: "Receiver type".
            __BootstrapCompiler__ print: node receiver _ analyzedType.
            analyzer makeSemanticAnalysisError: "Unsupported dynamic message send." at: node sourcePosition
        }
    };
    withSelector: #analyzeDynamicMessageSendNode:with: addMethod: {:(Type)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        let: #analyzedNode with: node shallowCopy.
        analyzedNode
            selector: (analyzer analyzeNodeIfNeeded: analyzedNode selector withExpectedType: self);
            arguments: (node arguments collect: {:(Reflection AST Node)argumentNode :: Reflection AST Node |
                analyzer analyzeNodeIfNeeded: argumentNode withExpectedType: AnyValue
            });
            usesDynamicDispatch: true;
            yourself
    };
    withSelector: #analyzeIdentifierReferenceNode:with:valueBinding: addMethod: {:(Type)self :(Reflection AST IdentifierReferenceNode)node :(Reflection Semantic ASTAnalyzer)analyzer :(Reflection Semantic SymbolValueBinding)binding :: Reflection AST Node |
        Reflection AST LiteralValueNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            analyzedType: self.
            value: binding value
        }
    };
    withSelector: #supportsDynamicDispatch addMethod: {:(Type)self :: AnyValue |
        <primitive: #"type.supportsDynamicDispatch">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asReferenceDecayedType addMethod: {:(Type)self :: Type |
        self
    };
    withSelector: #asDecayedType addMethod: {:(Type)self :: Type |
        self
    };
    withSelector: #isSubtypeOf: addMethod: {:(Type)self :(Type)other :: Boolean |
        <primitive: #"type.isSubtypeOf">
        if: self == other then: {
            true
        } else: {
            if: self supertype isNil then: {
                false
            } else: {
                self supertype _ isSubtypeOf: other
            }
        }
    };
    withSelector: #hasTypeFlag: addMethod: {:(Type)self :(AnyValue)methodFlag :: Boolean |
        <primitive: #"type.hasTypeFlag">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #hasAnyValueFlag addMethod: {:(Type)self :: Boolean |
        self hasTypeFlag: #anyValue
    };

    withSelector: #addImplicitCoercionToNode:targetType:with: addMethod: {:(Type)self
        :(Reflection AST Node)node :(Type)targetType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self == targetType then: {
            node
        } else: {
            if: (self isSubtypeOf: targetType) then: {
                Reflection AST UpcastConversionNode basicNewWithNamedSlots: #{
                    sourcePosition: node sourcePosition.
                    expression: node.
                    analyzedType: targetType
                }
            } else: {
                targetType addImplicitCoercionToNode: node fromType: self with: analyzer
            }
        }
    };
    withSelector: #addImplicitCoercionToNode:fromType:with: addMethod: {:(Type)self
        :(Reflection AST Node)node :(Type)fromType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self == fromType then: {
            node
        } else: {
            if: self hasAnyValueFlag then: {
                Reflection AST WrapAnyValueNode basicNewWithNamedSlots: #{
                    sourcePosition: node sourcePosition.
                    expression: node.
                    analyzedType: self
                }
            } else: {
                if: (self schema canConstructWithValueOfType: fromType) then: {
                    self schema addConstructionNodeFor: node valueType: fromType into: self with: analyzer
                } else: {
                    analyzer makeSemanticAnalysisError: ("Failed to perform implicit conversion {0} -> {1}" format: (fromType printString, self printString)) at: node sourcePosition
                }
            }
        }
    }.

Reflection TypeSchema 
    withSelector: #canConstructWithValueOfType: addMethod: {:(TypeSchema)self :(Type)sourceType :: Boolean |
        false
    };
    withSelector: #addConstructionNodeFor:valueType:into:with: addMethod: {:(TypeSchema)self :(Reflection AST Node)node :(Type)sourceType :(Type)targetType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        __BootstrapCompiler__ subclassResponsibility
    }.

Reflection SumTypeSchema 
    withSelector: #containsType: addMethod: {:(SumTypeSchema)self :(Type)typeToCheck :: Boolean |
        <primitive: #"sumTypeSchema.containsType" >
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #getTypeSelectorIndexFor: addMethod: {:(SumTypeSchema)self :(Type)elementType :: Size |
        <primitive: #"sumTypeSchema.getTypeSelectorIndexFor" >
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canConstructWithValueOfType: addMethod: {:(SumTypeSchema)self :(Type)sourceType :: Boolean |
        self containsType: sourceType
    };
    withSelector: #addConstructionNodeFor:valueType:into:with: addMethod: {:(TypeSchema)self :(Reflection AST Node)node :(Type)sourceType :(Type)targetType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        Reflection AST WrapValueInSumTypeNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            expression: node.
            typeSelector: (self getTypeSelectorIndexFor: sourceType).
            analyzedType: targetType.
        }
    }.

Void __type__
    withSelector: #addImplicitCoercionToNode:fromType:with: addMethod: {:(Type)self
        :(Reflection AST Node)node :(Type)fromType :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self == fromType then: {
            node
        } else: {
            Reflection AST ValueAsVoidNode basicNewWithNamedSlots: #{
                sourcePosition: node sourcePosition.
                expression: node.
                analyzedType: self
            }
        }
    }.

Function __type__
    withSelector: #canonicalArgumentTypes addMethod: {:(Function __type__)self :: Type arraySlice |
        <primitive: #"functionType.getCanonicalArgumentTypes">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canonicalResultType addMethod: {:(Function __type__)self :: Type |
        <primitive: #"functionType.getCanonicalResultType">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #makeFunctionSignatureAnalyzer addMethod: {:(Function __type__)self :: Reflection Semantic FunctionSignatureAnalyzer |
        <primitive: #"functionType.makeFunctionSignatureAnalyzer">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #analyzeMessageSendNode:with:valueBinding: addMethod: {:(Function __type__)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :(Reflection Semantic SymbolValueBinding)binding :: Reflection AST Node |
        binding value analyzeMessageSendNode: node with: analyzer
    };
    withSelector: #analyzeIdentifierReferenceNode:with:valueBinding: addMethod: {:(Function __type__)self :(Reflection AST IdentifierReferenceNode)node :(Reflection Semantic ASTAnalyzer)analyzer :(Reflection Semantic SymbolValueBinding)binding :: Reflection AST Node |
        if: binding value hasMacroFlag & binding value hasMessageMethodFlag then: {
            analyzer analyzeNodeIfNeededWithCurrentExpectedType: (binding value
                run: node value
                with: AnyValue arraySlice basicNew
                in: (analyzer makeMacroInvocationContextForIdentifierReferenceNode: node)
            )
        } else: {
            Reflection AST LiteralValueNode basicNewWithNamedSlots: #{
                sourcePosition: node sourcePosition.
                analyzedType: self.
                value: binding value
            }
        }
    }.

Reflection Semantic FunctionSignatureAnalyzer
    withSelector: #hasPendingArguments addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :: Boolean |
        <primitive: #"functionSignatureAnalyzer.hasPendingArguments">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #evaluateNextSignatureType addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :: Reflection Semantic TypeOrForAllPlaceholder |
        <primitive: #"functionSignatureAnalyzer.evaluateNextSignatureType">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #computeResultType addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :: Type |
        <primitive: #"functionSignatureAnalyzer.computeResultType">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #advanceArgumentWithAnalyzedType: addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :(Type)analyzedType :: Void |
        <primitive: #"functionSignatureAnalyzer.advanceArgument">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #analyzeReceiverArgumentNode:with: addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        self analyzeArgumentNode: node with: analyzer
    };
    withSelector: #analyzeArgumentNode:with: addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self hasPendingArguments then: {
            let: #signatureTypeOrPlaceholder with: self evaluateNextSignatureType.
            let: #analyzedNode with: (if: (signatureTypeOrPlaceholder is: Reflection Semantic ForAllPlaceholderBinding) then: {
                let: #placeholder with: (signatureTypeOrPlaceholder get: Reflection Semantic ForAllPlaceholderBinding).
                let: #directNode with: (analyzer analyzeNodeIfNeeded: node withTypeInferenceEnvironment: signatureType makeTypeInferenceEnvironment).

                if: (signatureType matchAndSolveWithType: directNode _ analyzedType) then: {
                    directNode
                } else: {
                    analyzer makeSemanticAnalysisError: "Generic argument type is not matching" atNode: directNode
                }
            } else: {
                let: #expectedType with: (signatureTypeOrPlaceholder get: Type).
                analyzer analyzeNodeIfNeeded: node withExpectedType: expectedType
            }).

            self advanceArgumentWithAnalyzedType: analyzedNode analyzedType _.
            analyzedNode
        } else: {
            analyzer makeSemanticAnalysisError: "Unexpected excessive argument." atNode: (analyzer analyzeNodeIfNeededWithAutoType: node)
        }
    };
    withSelector: #annotateExtraSemanticAnalysisErrorsOn:with: addMethod: {:(Reflection Semantic FunctionSignatureAnalyzer)self :(Reflection AST Node)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self hasPendingArguments then: {
            analyzer makeSemanticAnalysisError: "Missing required arguments." atNode: node
        } else: {
            node
        }
    }.

Function
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Function)self :(Reflection AST MessageSendNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self hasMacroFlag then: {
            analyzer analyzeNodeIfNeededWithCurrentExpectedType: (self
                run: (node selector analyzeAndEvaluateNodeWith: analyzer)
                with: node arguments
                in: (analyzer makeMacroInvocationContextForMessageSendNode: node)
            )
        } else: {
            let: #signatureAnalyzer with: self __type__ makeFunctionSignatureAnalyzer.
            let: #analyzedNode with: node shallowCopy.

            if: analyzedNode receiver isNotNil then: {
                analyzedNode receiver: (signatureAnalyzer analyzeReceiverArgumentNode: analyzedNode receiver _ with: analyzer)
            } else: {void}.

            analyzedNode
                arguments: (node arguments collect: {:(Reflection AST Node)node :: Reflection AST Node |
                    signatureAnalyzer analyzeArgumentNode: node with: analyzer
                });
                analyzedType: signatureAnalyzer computeResultType;
                boundMethod: self;
                usesDynamicDispatch: node receiver _ analyzedType _ supportsDynamicDispatch & self usesDynamicDispatch.

            signatureAnalyzer annotateExtraSemanticAnalysisErrorsOn: analyzedNode with: analyzer
        }.
    };
    withSelector: #run:with:in: addMethod: {:(Function)self :(AnyValue)selector :(AnyValue arraySlice)arguments :(AnyValue)receiver :: AnyValue |
        <primitive: #"object.runWithIn">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #hasMethodFlag: addMethod: {:(Function)self :(AnyValue)methodFlag :: Boolean |
        <primitive: #"function.hasMethodFlag">
        __BootstrapCompiler__ primitiveFailed
    };

    ## Macro
    withSelector: #hasMacroFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #macro
    };
    withSelector: #hasMessageMethodFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #messageMethod
    };
    withSelector: #hasFallbackFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #fallback
    };

    ## Side effects
    withSelector: #hasPureFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #pure
    };

    ## Dispatch mode
    withSelector: #hasAbstractFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #abstract
    };
    withSelector: #hasVirtualFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #virtual
    };
    withSelector: #hasOverrideFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #override
    };
    withSelector: #hasStaticFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #static
    };
    withSelector: #hasFinalFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #final
    };

    withSelector: #hasDynamicDispatchFlag addMethod: {:(Function)self :: Boolean |
        self hasAbstractFlag | self hasVirtualFlag | self hasOverrideFlag
    };

    withSelector: #usesDynamicDispatch addMethod: {:(Function)self :: Boolean |
        self hasDynamicDispatchFlag & self hasFinalFlag not 
    }.
