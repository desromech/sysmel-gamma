__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #Reflection;
    addBindingNamed: #ArgumentVariable with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection FunctionVariable publicSlots: #{
        isAnalyzingSignature: Boolean.
        hasDependentTypeAccess: Boolean.
    });

    enterNamespaceNamed: #AST;
    addBindingNamed: #ArgumentDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: Reflection AST Node publicSlots: #{
        nameExpression: Reflection AST Node optional.
        typeExpression: Reflection AST Node optional.
        analyzedName: Object optional.
        analyzedTypeExpression: Reflection AST Node optional.
        analyzedVariable: Reflection ArgumentVariable optional.
        isGenericForallArgument: Boolean.
        isImplicitArgument: Boolean.
    }).

Reflection ArgumentVariable
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(Reflection ArgumentVariable)self :(Reflection AST IdentifierReferenceNode)node :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self isAnalyzingSignature then: {
            self hasDependentTypeAccess: true
        } else: {void}.

        Reflection AST FunctionVariableReferenceNode basicNewWithNamedSlots: #{
            binding: self.
            analyzedType: self referenceType
        }
    }.

Reflection AST Node
    withSelector: #parseAsArgumentDefinitionNode addMethod: {:(Reflection AST Node)self :: Reflection AST Node |
        Reflection AST SemanticErrorNode basicNewWithNamedSlots: #{
            analyzedType: CompilationError.
            sourcePosition: self sourcePosition.
            message: "Expression cannot be interpred as an argument definition node.".
            innerNode: self
        }.
    };
    withSelector: #parseAsArgumentDefinitionNodes addMethod: {:(Reflection AST Node)self :: Reflection AST Node sharedArraySlice |
        Reflection AST Node sharedArraySlice with: self parseAsArgumentDefinitionNode
    }.

Reflection AST ArgumentDefinitionNode __type__
    withSelector: #withName:type:at: addMethod: {:(Reflection AST ArgumentDefinitionNode)self :(Object)name :(Type)type :(Reflection AST SourcePosition)sourcePosition :: self |
        self basicNewWithNamedSlots: #{
            sourcePosition: sourcePosition.
            nameExpression: (Reflection AST LiteralValueNode withValue: name at: sourcePosition).
            typeExpression: (Reflection AST LiteralValueNode withValue: type at: sourcePosition)
        }
    }.

Reflection AST ArgumentDefinitionNode
    withSelector: #analyzeNodeWith: addMethod: {:(Reflection AST ArgumentDefinitionNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Reflection AST Node |
        if: self nameExpression isNil & self typeExpression isNil then: {
            analyzer makeSemanticAnalysisError: "Argument definition node requires at least a name or a type" at: self sourcePosition
        } else: {
            let: #analyzedNode with: self shallowCopy.

            let: #name with: (if: self nameExpression isNotNil
                then: (self nameExpression _ analyzeAndEvaluateNodeWith: analyzer)
                else: (Reflection AnonymousSymbol basicNewWithNamedSlots: #{
                    sourcePosition: self sourcePosition
                })
            ).
            let: #sanitizedName with: (name asSanitizedNameSymbolFor: self sourcePosition).
            let: #errorNode with: (Reflection AST Node optional valueBox with: nil).
            let: #existentBinding with: (analyzer environment lexicalScope lookupSymbol: sanitizedName).
            analyzedNode analyzedName: sanitizedName.

            if: existentBinding isNotNil then: {
                errorNode _: (analyzer makeSemanticAnalysisError: ("Argument definition for {0} overrides a previous argument." format: (sanitizedName printString,) at: analyzedNode sourcePosition))
            } else: { void }.

            if: analyzedNode typeExpression isNotNil then: {
                analyzedNode analyzedTypeExpression: (analyzer analyzeNodeIfNeeded: analyzedNode typeExpression _ withExpectedType: Type)
            } else: {
                __BootstrapCompiler__ printLine: "TODO: infer or set block closure default argument type.".
                __BootstrapCompiler__ primitiveFailed
            }.

            if: errorNode _ isNotNil then: {
                errorNode _ _
            } else: {
                let: #argumentVariableType with: (analyzedNode computeArgumentVariableAnalysisTypeWith: analyzer).

                let: #argumentVariable with: (Reflection ArgumentVariable basicNewWithNamedSlots: #{
                    name: sanitizedName.
                    valueType: argumentVariableType.
                    referenceType: argumentVariableType.
                    isAnalyzingSignature: true
                }).

                analyzer environment lexicalScope setSymbol: sanitizedName variableBinding: argumentVariable.

                analyzedNode 
                    analyzedVariable: argumentVariable;
                    analyzedType: Reflection ArgumentVariable;
                    yourself
            }.
        }.
    };
    withSelector: #computeArgumentVariableAnalysisTypeWith: addMethod: {:(Reflection AST ArgumentDefinitionNode)self :(Reflection Semantic ASTAnalyzer)analyzer :: Type |
        if: (self analyzedTypeExpression _ isCompileTimeDirectlyEvaluableWith: analyzer environment) then: {
            self analyzedTypeExpression: (self analyzedTypeExpression _ optimizeViaCompileTimeEvaluationWith: analyzer environment).
            self analyzedTypeExpression _ evaluateNodeWith: analyzer environment
        } else: {
            AnyValue
        }
    };
    withSelector: #getArgumentVariable addMethod: {:(Reflection AST ArgumentDefinitionNode)self :: Reflection ArgumentVariable |
        self analyzedVariable _
    };
    withSelector: #parseAsArgumentDefinitionNode addMethod: {:(Reflection AST ArgumentDefinitionNode)self :: Reflection AST Node |
        self
    }.


Reflection AST IdentifierReferenceNode
    withSelector: #parseAsArgumentDefinitionNode addMethod: {:(Reflection AST IdentifierReferenceNode)self :: Reflection AST Node |
        Reflection AST ArgumentDefinitionNode basicNewWithNamedSlots: #{
            nameExpression: self asLiteralSymbolNode.
        }.
    }.

Reflection AST LiteralValueNode
    withSelector: #convertSelectorToArgumentName addMethod: {:(Reflection AST LiteralValueNode)self :: Reflection AST Node |
        self shallowCopy
            value: (self value withoutSuffix: ":");
            yourself
    }.

Reflection AST MessageSendNode
    withSelector: #parseAsArgumentDefinitionNode addMethod: {:(Reflection AST MessageSendNode)self :: Reflection AST Node |
        if: self receiver isNil & (self arguments size = 1sz) & self selector isLiteralValueNode then: {
            Reflection AST ArgumentDefinitionNode basicNewWithNamedSlots: #{
                nameExpression: self selector convertSelectorToArgumentName.
                typeExpression: (self arguments basicAt: 0)
            }
        } else: {
            Reflection AST SemanticErrorNode basicNewWithNamedSlots: #{
                analyzedType: CompilationError.
                sourcePosition: self sourcePosition.
                message: "Message send expression is not valid argument definition".
                innerNode: self
            }.
        }.
    }.

Reflection AST MakeTupleNode
    withSelector: #parseAsArgumentDefinitionNodes addMethod: {:(Reflection AST MakeTupleNode)self :: Reflection AST Node sharedArraySlice |
        self elements collect: {:(Reflection AST Node)node :: Reflection AST Node |
            node parseAsArgumentDefinitionNode
        }
    }.