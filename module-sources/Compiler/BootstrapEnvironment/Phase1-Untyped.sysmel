## This is the Phase1, where the core basic type system is defined along with the global bindings.
## In this stage the compiler environment itself is completely empty,
## except for a single reference to the bootstrap compiler itself.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Type theory fundamentals
    addBasicTypeNamed: #Absurd with: __TypeBuilder__ newAbsurdType;
    addBasicTypeNamed: #Trivial with: __TypeBuilder__ newTrivialType;

    addBasicTypeNamed: #False with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #True with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Boolean with: (__TypeBuilder__ newSumTypeWith: (False, True));
    addBasicTypeNamed: #Undefined with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Void with: __TypeBuilder__ newTrivialType;

    ## Base type system
    addBasicTypeNamed: #AnyValue with: (__TypeBuilder__ newGCClassWithSlots: #{});

    addBasicTypeNamed: #Object with: (__TypeBuilder__ newGCClassWithSuperclass: AnyValue slots: #{});
    addBasicTypeNamed: #Type with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #SimpleType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});
    addBasicTypeNamed: #MetaType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});

    addBasicTypeNamed: #Function with: (__TypeBuilder__ newGCClassWithSuperclass: SimpleType slots: #{});
    addBasicTypeNamed: #FunctionImplementation with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #BlockClosure with: (__TypeBuilder__ newGCClassWithSuperclass: FunctionImplementation slots: #{});
    addBasicTypeNamed: #AbstractPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: FunctionImplementation slots: #{});
    addBasicTypeNamed: #PrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #TypeSchemaPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeAccessorPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeGetterPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: RecordTypeAccessorPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeSetterPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: RecordTypeAccessorPrimitiveMethod slots: #{});

    addBasicTypeNamed: #String with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Symbol with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Integer with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Float with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    
    addBasicTypeNamed: #CompilationError with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{}).

AnyValue addTypeFlag: #anyValue.

## Integer arithmetics primitive methods
Integer
    withSelector: #+ addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.add">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #- addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.sub">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #"*" addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.mul">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #// addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.div">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #% addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.rem">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.equals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #~= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.notEquals">
        __BootstrapCompiler__ primitiveFailed
    };
    
    withSelector: #< addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.lessThan">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #<= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.lessOrEqual">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #> addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.greaterThan">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #>= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.greaterOrEqual">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #asString addMethod: {:(Integer)self :: String |
        <primitive: #"integer.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Integer)self :: String |
        <primitive: #"integer.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    }.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Important keywords
    addKeywordBindingNamed: #false with: False basicNew;
    addKeywordBindingNamed: #true with: True basicNew;
    addKeywordBindingNamed: #nil with: Undefined basicNew;
    addKeywordBindingNamed: #void with: Void basicNew;

    ## The primitive types
    addBasicTypeNamed: #Boolean8 with: (__TypeBuilder__ newBooleanTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Boolean16 with: (__TypeBuilder__ newBooleanTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Boolean32 with: (__TypeBuilder__ newBooleanTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #UInt8 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #UInt16 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #UInt32 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #UInt64 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Int8 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Int16 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Int32 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Int64 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Char8 with: (__TypeBuilder__ newCharacterTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Char16 with: (__TypeBuilder__ newCharacterTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Char32 with: (__TypeBuilder__ newCharacterTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #Float16 with: (__TypeBuilder__ newFloatTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Float32 with: (__TypeBuilder__ newFloatTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Float64 with: (__TypeBuilder__ newFloatTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #UIntPointer with: (if: __BootstrapCompiler__ getPointerSize = 4 then: UInt32 else: UInt64);
    addBasicTypeNamed: #IntPointer with: (if: __BootstrapCompiler__ getPointerSize = 4 then: Int32 else: Int64);
    addBasicTypeNamed: #Size with: UIntPointer.

## Integer conversion primitives
Integer
    withSelector: #u8 addMethod: {:(Integer)self :: UInt8 |
        <primitive: #"integer.conversion.toUInt8">
        UInt8 basicNew: self
    };
    withSelector: #s8 addMethod: {:(Integer)self :: Int8 |
        <primitive: #"integer.conversion.toInt8">
        Int8 basicNew: self
    };
    withSelector: #u16 addMethod: {:(Integer)self :: UInt16 |
        <primitive: #"integer.conversion.toUInt16">
        UInt16 basicNew: self
    };
    withSelector: #s16 addMethod: {:(Integer)self :: Int16 |
        <primitive: #"integer.conversion.toInt16">
        Int16 basicNew: self
    };
    withSelector: #u32 addMethod: {:(Integer)self :: UInt32 |
        <primitive: #"integer.conversion.toUInt32">
        UInt32 basicNew: self
    };
    withSelector: #s32 addMethod: {:(Integer)self :: Int32 |
        <primitive: #"integer.conversion.toInt32">
        Int32 basicNew: self
    };
    withSelector: #u64 addMethod: {:(Integer)self :: UInt64 |
        <primitive: #"integer.conversion.toUInt64">
        UInt64 basicNew: self
    };
    withSelector: #s64 addMethod: {:(Integer)self :: Int64 |
        <primitive: #"integer.conversion.toInt64">
        Int64 basicNew: self
    };

    withSelector: #sz addMethod: {:(Integer)self :: Size |
        <primitive: #"integer.conversion.toSize">
        Size basicNew: self
    };
    withSelector: #uptr addMethod: {:(Integer)self :: UIntPointer |
        <primitive: #"integer.conversion.toUIntPointer">
        UIntPointer basicNew: self
    };
    withSelector: #uptr addMethod: {:(Integer)self :: IntPointer |
        <primitive: #"integer.conversion.toIntPointer">
        IntPointer basicNew: self
    }.

{:addPrimitivesBlock |
    addPrimitivesBlock(UInt8).
    addPrimitivesBlock(Int8).
    addPrimitivesBlock(UInt16).
    addPrimitivesBlock(Int16).
    addPrimitivesBlock(UInt32).
    addPrimitivesBlock(Int32).
    addPrimitivesBlock(UInt64).
    addPrimitivesBlock(Int64).
}({:(Type)primitiveIntegerType |
    primitiveIntegerType
        withSelector: #+ addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <primitive: #"primitiveInteger.arithmetic.add">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #- addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <primitive: #"primitiveInteger.arithmetic.sub">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #"*" addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <primitive: #"primitiveInteger.arithmetic.mul">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #// addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <primitive: #"primitiveInteger.arithmetic.div">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #% addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <primitive: #"primitiveInteger.arithmetic.rem">
            __BootstrapCompiler__ primitiveFailed
        };

        withSelector: #= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean8 |
            <primitive: #"primitiveInteger.comparison.equals">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #~= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean8 |
            <primitive: #"primitiveInteger.comparison.notEquals">
            __BootstrapCompiler__ primitiveFailed
        };
        
        withSelector: #< addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean8 |
            <primitive: #"primitiveInteger.comparison.lessThan">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #<= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean8 |
            <primitive: #"primitiveInteger.comparison.lessOrEqual">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #> addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean8 |
            <primitive: #"primitiveInteger.comparison.greaterThan">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #>= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean8 |
            <primitive: #"primitiveInteger.comparison.greaterOrEqual">
            __BootstrapCompiler__ primitiveFailed
        };

        withSelector: #asString addMethod: {:(Integer)self :: String |
            <primitive: #"primitiveInteger.conversion.toString">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #printString addMethod: {:(Integer)self :: String |
            <primitive: #"primitiveInteger.conversion.toString">
            __BootstrapCompiler__ primitiveFailed
        }.
}).

__BootstrapCompiler__
    enterTopLevelNamespace;
    
    ## The polymorphic types
    addBasicTypeNamed: #Optional with: {:(Type)optionalType :: Type |
        {:(Type)sumType :: Type |
            sumType
                withSelector: #isNil addMethod: {:(sumType)self :: Boolean |
                    self __typeSelector__ = 0
                };
                withSelector: #isNotNil addMethod: {:(sumType)self :: Boolean |
                    self __typeSelector__ ~= 0
                };
                withSelector: #_ addMethod: {:(sumType)self :: optionalType |
                    self get: optionalType
                };
                withSelector: #value addMethod: {:(sumType)self :: optionalType |
                    self get: optionalType
                }.
            sumType
        }(__TypeBuilder__ newSumTypeWith: (Undefined, optionalType))
    } templated;

    addBasicTypeNamed: #Array with: {:(Type)elementType :(Size)bounds :: Type |
        {:(Type)arrayType :: Type |
            arrayType
                withSelector: #asArraySlice addMethod: {:(arrayType)self :: ArraySlice(elementType) |
                    ArraySlice(elementType) basicNewWithNamedSlots: #{
                        elements: self.
                        size: bounds
                    }
                };
                withSelector: #size addMethod: {:(arrayType)self :: Size |
                    bounds
                }.
            arrayType
        } (__TypeBuilder__ newArrayTypeFor: elementType withBounds: bounds)
    } templated;

    addBasicTypeNamed: #Pointer with: {:(Type)elementType :: Type |
        __TypeBuilder__ newPointerTypeFor: elementType
    } templated;

    addBasicTypeNamed: #ArraySlice with: {:(Type)elementType :: Type |
        {:(Type)arraySliceType :: Type |
            arraySliceType
                withSelector: #isEmpty addMethod: {:(arraySliceType)self :: Boolean8 |
                    self size = 0sz
                };
                withSelector: #isNotEmpty addMethod: {:(arraySliceType)self :: Boolean8 |
                    self size ~= 0sz
                };
                withSelector: #basicAt: addMethod: {:(arraySliceType)self :(Size)index :: elementType |
                    self elements basicAt: index
                };
                withSelector: #first addMethod: {:(arraySliceType)self :: elementType |
                    self basicAt: 0sz
                };
                withSelector: #last addMethod: {:(arraySliceType)self :: elementType |
                    self basicAt: self size - 1sz
                };
                withSelector: #collect: addMethod: {:*(Type)ResultType :(elementType => ResultType)block :: ArraySlice(ResultType) |
                    <primitive: #"arraySlice.collect">
                    __BootstrapCompiler__ primitiveFailed
                };
                withSelector: #collectWithIndex: addMethod: {:*(Type)ResultType :((elementType -- Size) => ResultType)block :: ArraySlice(ResultType) |
                    <primitive: #"arraySlice.collectWithIndex">
                    __BootstrapCompiler__ primitiveFailed
                };
                withSelector: #do: addMethod: {:*(Type)ResultType :((elementType) => ResultType)block :: ResultType |
                    <primitive: #"arraySlice.do">
                    __BootstrapCompiler__ primitiveFailed
                }.
            arraySliceType
        } (__TypeBuilder__ newRecordTypeWith: #{
            elements: Pointer(elementType).
            size: Size.
        })
    } templated;
    addBasicTypeNamed: #AnyArraySlice with: ArraySlice(AnyValue);

    addBasicTypeNamed: #Association with: {:(Type)key :(Type)value :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            key: key.
            value: value.
        }
    } templated;
    addBasicTypeNamed: #AnyAssociation with: Association(AnyValue, AnyValue);

    addBasicTypeNamed: #ArrayDictionary with: {:(Type)keyType :(Type)valueType :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            associationList: ArraySlice(Association(keyType, valueType)).
            hashTable: ArraySlice(UInt32).
        }
    } templated;
    addBasicTypeNamed: #AnyArrayDictionary with: ArrayDictionary(AnyValue, AnyValue);

    addBasicTypeNamed: #ArrayList with: {:(Type)elementType :: Type |
        __TypeBuilder__ newGCClassWithSlots: #{
            size: Size.
            storage: ArraySlice(elementType)
        }
    } templated;
    addBasicTypeNamed: #AnyArrayList with: ArrayList(AnyValue).

## String primitive methods
String
    withSelector: #-- addMethod: {:(String)self :(String)other :: String |
        <primitive: #"string.concat">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #format: addMethod: {:(String)self :(String arraySlice)parameters :: String |
        <primitive: #"string.format">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asSymbol addMethod: {:(String)self :: Symbol |
        <primitive: #"symbol.internString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asString addMethod: {:(String)self :: String |
        self
    };
    withSelector: #printString addMethod: {:(String)self :: String |
        <primitive: #"string.conversion.printString">
        self
    }.

Symbol
    withSelector: #asString addMethod: {:(Integer)self :: String |
        <primitive: #"symbol.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Integer)self :: String |
        <primitive: #"symbol.conversion.printString">
        __BootstrapCompiler__ primitiveFailed
    }.

## Basic type system methods.
MetaType
    withSelector: #"[]" addMethod: {:(Type)self :: Type |
        Array(self, 0)
    };
    withSelector: #"[]" addMethod: {:(Type)self :(Size)bounds :: Type |
        Array(self, bounds)
    };
    withSelector: #optional addMethod: {:(Type)self :: Type |
        Optional(self)
    };
    withSelector: #array addMethod: {:(Type)self :: Type |
        Array(self, 0)
    };
    withSelector: #array: addMethod: {:(Type)self :(Size)bounds :: Type |
        Array(self, bounds)
    };
    withSelector: #arraySlice addMethod: {:(Type)self :: Type |
        ArraySlice(self)
    };
    withSelector: #arrayList addMethod: {:(Type)self :: Type |
        ArrayList(self)
    }.

## Basic methods.
AnyValue
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        false
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        true
    }.

Undefined
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        true
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        false
    }.

## The AST nodes.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #SysmelCompiler;
    enterNamespaceNamed: #AST;
    addBindingNamed: #SourceCollection with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourcePosition with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourceStringCollection with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourceCollection publicSlots: #{
        sourceString: String.
        name: String.
    });
    addBindingNamed: #SourceStringPosition with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourcePosition publicSlots: #{
        sourceCollection: SysmelCompiler AST SourceCollection.
        startPosition: Size.
        endPosition: Size.
        startLine: Size.
        startColumn: Size.
        endLine: Size.
        endColumn: Size.
    });
    addBindingNamed: #EmptySourcePosition with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourcePosition publicSlots: #{});

    addBindingNamed: #Node with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition.
        analyzedType: Type optional
    });
    addBindingNamed: #ArgumentDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        name: SysmelCompiler AST Node.
        type: SysmelCompiler AST Node.
    });
    addBindingNamed: #BlockClosureNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        arguments: SysmelCompiler AST Node arraySlice.
        body: SysmelCompiler AST Node.
    });
    addBindingNamed: #ChainedMessageNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        selector: SysmelCompiler AST Node.
        arguments: SysmelCompiler AST Node arraySlice
    });
    addBindingNamed: #CleanUpScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        body: SysmelCompiler AST Node.
        cleanUpAction: SysmelCompiler AST Node optional.
    });
    addBindingNamed: #LexicalScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        body: SysmelCompiler AST Node
    });
    addBindingNamed: #LiteralValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        value: AnyValue
    });
    addBindingNamed: #IdentifierReferenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        value: AnyValue.
        binding: AnyValue.
    });

    addBindingNamed: #MakeAssociationNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        key: SysmelCompiler AST Node.
        value: SysmelCompiler AST Node.
    });
    addBindingNamed: #MakeTupleNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        elements: SysmelCompiler AST Node arraySlice.
    });
    addBindingNamed: #MakeDictionaryNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        elements: SysmelCompiler AST Node arraySlice.
    });

    addBindingNamed: #MessageSendNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        receiver: SysmelCompiler AST Node optional.
        selector: SysmelCompiler AST Node.
        arguments: SysmelCompiler AST Node arraySlice.
        boundMethod: AnyValue optional.
    });
    addBindingNamed: #MessageChainNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        receiver: SysmelCompiler AST Node.
        chainedMessages: SysmelCompiler AST Node arraySlice
    });
    addBindingNamed: #SequenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expressions: SysmelCompiler AST Node arraySlice.
        pragmas: SysmelCompiler AST Node arraySlice.
    });

    addBindingNamed: #SpliceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuasiQuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuasiUnquoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });

    addBindingNamed: #ErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        message: String
    });
    addBindingNamed: #ParseErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST ErrorNode publicSlots: #{});
    addBindingNamed: #SemanticErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST ErrorNode publicSlots: #{});

    ## Stablish the basic ast node mapping that is required for converting a parse tree onto the actual AST object.
    setParseTreeASTMaping: #{
        SourceCollection: SysmelCompiler AST SourceCollection.
        SourcePosition: SysmelCompiler AST SourcePosition.
        SourceStringCollection: SysmelCompiler AST SourceStringCollection.
        SourceStringPosition: SysmelCompiler AST SourceStringPosition.
        EmptySourcePosition: SysmelCompiler AST EmptySourcePosition.

        Node: SysmelCompiler AST Node.
        NodeArrayList: SysmelCompiler AST Node arrayList.
        NodeArraySlice: SysmelCompiler AST Node arraySlice.

        ArgumentDefinitionNode: SysmelCompiler AST ArgumentDefinitionNode.
        BlockClosureNode: SysmelCompiler AST BlockClosureNode.
        ChainedMessageNode: SysmelCompiler AST ChainedMessageNode.
        CleanUpScopeNode: SysmelCompiler AST CleanUpScopeNode.
        IdentifierReferenceNode: SysmelCompiler AST IdentifierReferenceNode.
        LexicalScopeNode: SysmelCompiler AST LexicalScopeNode.
        LiteralValueNode: SysmelCompiler AST LiteralValueNode.
        MakeAssociationNode: SysmelCompiler AST MakeAssociationNode.
        MakeDictionaryNode: SysmelCompiler AST MakeDictionaryNode.
        MakeTupleNode: SysmelCompiler AST MakeTupleNode.
        MessageSendNode: SysmelCompiler AST MessageSendNode.
        MessageChainNode: SysmelCompiler AST MessageChainNode.
        QuoteNode: SysmelCompiler AST QuoteNode.
        QuasiQuoteNode: SysmelCompiler AST QuasiQuoteNode.
        QuasiUnquoteNode: SysmelCompiler AST QuasiUnquoteNode.
        SequenceNode: SysmelCompiler AST SequenceNode.
        SpliceNode: SysmelCompiler AST SpliceNode.

        ErrorNode: SysmelCompiler AST ErrorNode.
        ParseErrorNode: SysmelCompiler AST ParseErrorNode.
        SemanticErrorNode: SysmelCompiler AST SemanticErrorNode.
    }.

## Semantic analysis types.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #SysmelCompiler;
    enterNamespaceNamed: #Semantic;
    addBindingNamed: #SymbolBinding with: (__TypeBuilder__ newGCClassWithPublicSlots: #{});
    addBindingNamed: #SymbolImmutableValueBinding with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic SymbolBinding publicSlots: #{
        name: AnyValue.
        value: AnyValue
    });
    addBindingNamed: #IdentifierLookupScope with: (__TypeBuilder__ newGCClassWithPublicSlots: #{});
    addBindingNamed: #LexicalScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic IdentifierLookupScope publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #NamespaceScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic LexicalScope publicSlots: #{});
    addBindingNamed: #ScriptEvaluationScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic LexicalScope publicSlots: #{});
    addBindingNamed: #EvaluationEnvironment with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        lexicalScope: SysmelCompiler Semantic LexicalScope
    });
    addBindingNamed: #ASTAnalyzer with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        environment: SysmelCompiler Semantic EvaluationEnvironment
    });
    setSemanticAnalysisMapping: #{
        SymbolBinding: SysmelCompiler Semantic SymbolBinding.
        SymbolImmutableValueBinding: SysmelCompiler Semantic SymbolImmutableValueBinding.
        IdentifierLookupScope: SysmelCompiler Semantic IdentifierLookupScope.
        LexicalScope: SysmelCompiler Semantic LexicalScope.
        NamespaceScope: SysmelCompiler Semantic NamespaceScope.
        ScriptEvaluationScope: SysmelCompiler Semantic ScriptEvaluationScope.
        EvaluationEnvironment: SysmelCompiler Semantic EvaluationEnvironment.
        ASTAnalyzer: SysmelCompiler Semantic ASTAnalyzer.
    }.

SysmelCompiler AST Node
    withSelector: #analyzeNodeIfNeededWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self analyzedType isNil then: {
            self analyzeNodeWith: analyzer
        } else: {
            self
        }
    };
    withSelector: #analyzeAndEvaluateNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: AnyValue |
        (self analyzeNodeIfNeededWith: analyzer) evaluateNodeWith: analyzer environment
    };
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #isLiteralValueNode addMethod: {:(SysmelCompiler AST Node)self :: Boolean |
        false
    };
    withSelector: #evaluateLiteralValue addMethod: {:(SysmelCompiler AST Node)self :: AnyValue |
        __BootstrapCompiler__ error: "Not a literal value node."
    };
    withSelector: #analyzeAndEvaluateNodeWithScriptEvaluationScope: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ScriptEvaluationScope)scope :: AnyValue |
        self analyzeAndEvaluateNodeWith: (SysmelCompiler Semantic ASTAnalyzer forScriptEvaluationScope: scope)
    }.

SysmelCompiler AST SourceStringCollection
    withSelector: #printString addMethod: {:(SysmelCompiler AST SourceStringCollection)self :: String |
        self name
    }.

SysmelCompiler AST SourceStringPosition
    withSelector: #printString addMethod: {:(SysmelCompiler AST SourceStringCollection)self :: String |
        "{0}:{1}.{2}-{3}.{4}" format: (self sourceCollection printString,
            self startLine printString, self startColumn printString,
            self endLine printString, self endColumn printString,
        )
    }.

SysmelCompiler AST LiteralValueNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST LiteralValueNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self shallowCopy
            analyzedType: self value __type__;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST LiteralValueNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self value
    };
    withSelector: #isLiteralValueNode addMethod: {:(SysmelCompiler AST LiteralValueNode)self :: Boolean |
        true
    };
    withSelector: #evaluateLiteralValue addMethod: {:(SysmelCompiler AST LiteralValueNode)self :: AnyValue |
        self value
    }.

SysmelCompiler AST CleanUpScopeNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST CleanUpScopeNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(SysmelCompiler AST Node)analyzedBody :: SysmelCompiler AST Node  |
            self shallowCopy
                body: analyzedBody;
                analyzedType: analyzedBody analyzedType _;
                yourself
        } (self body analyzeNodeIfNeededWith: analyzer)
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self body evaluateNodeWith: evaluationEnvironment
    }.

SysmelCompiler AST LexicalScopeNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST LexicalScopeNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(SysmelCompiler AST Node)analyzedBody :: SysmelCompiler AST Node  |
            self shallowCopy
                body: analyzedBody;
                analyzedType: analyzedBody analyzedType _;
                yourself
        } (self body analyzeNodeIfNeededWith: analyzer)
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self body evaluateNodeWith: evaluationEnvironment
    }.

SysmelCompiler AST SequenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST SequenceNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(SysmelCompiler AST Node arraySlice)analyzedPragmas :(SysmelCompiler AST Node arraySlice)analyzedExpressions :: SysmelCompiler AST Node  |
            self shallowCopy
                pragmas: analyzedPragmas;
                expressions: analyzedExpressions;
                analyzedType: (if: analyzedExpressions isEmpty then: Void else: analyzedExpressions last analyzedType _);
                yourself
        }(
            self pragmas collect: {:(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
                node analyzeNodeIfNeededWith: analyzer
            },
            self expressions collect: {:(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
                node analyzeNodeIfNeededWith: analyzer
            }
        )
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self expressions do: {:(SysmelCompiler AST Node)node :: AnyValue |
            node evaluateNodeWith: evaluationEnvironment
        }
    }.

SysmelCompiler AST IdentifierReferenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST IdentifierReferenceNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(AnyValue optional)binding :: SysmelCompiler AST Node  |
            if: binding isNil then: {
                analyzer makeSemanticAnalysisError: ("Failed to binding for symbol {0}." format: (self value printString, )) at: self sourcePosition
            } else: {
                binding _ analyzeIdentifierReferenceNode: self with: analyzer
            }
        }(analyzer environment lexicalScope lookupSymbolRecursively: self value)
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self binding evaluateBindingWithEnvironment: evaluationEnvironment
    }.

SysmelCompiler AST MessageSendNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST MessageSendNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(SysmelCompiler AST)analyzedSelector :: SysmelCompiler AST Node |
            if: self receiver isNil then: {
                if: analyzedSelector isLiteralSymbolValue then: {
                    {:(AnyValue)binding :: SysmelCompiler AST Node |
                        if: binding isNil then: {
                            analyzer makeSemanticAnalysisError: ("Failed to binding for selector {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
                        } else: {
                            binding analyzeMessageSendNode: (self shallowCopy
                                selector: analyzedSelector;
                                yourself) with: analyzer
                        }
                    } (analyzer environment lexicalScope lookupSymbolRecursively: (analyzedSelector evaluateNodeWith: analyzer))
                } else: {
                    analyzer makeSemanticAnalysisError: ("Message  {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
                }
            } else: {
                {:(SysmelCompiler AST Node)analyzedReceiver :: SysmelCompiler AST Node |
                    analyzedReceiver analyzedType _ analyzeMessageSendNode: (self shallowCopy
                        receiver: analyzedReceiver;
                        selector: analyzedSelector;
                        yourself) with: analyzer
                }(self receiver _ analyzeNodeIfNeededWith: analyzer)
            }.
        }(self selector analyzeNodeIfNeededWith: analyzer)
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST MessageSendNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: self receiver isNil then: {
            self boundMethod run: (self selector evaluateNodeWith: evaluationEnvironment) with: (self arguments collect: {:(SysmelCompiler AST Node)arg :: AnyValue |
                    arg evaluateNodeWith: evaluationEnvironment
                }) in: nil
        } else: {
            {:(AnyValue)receiver :(AnyValue)selector :(AnyValue arraySlice)arguments :: AnyValue |
                if: self boundMethod isNil then: {
                    receiver perform: selector withArguments: argumnets
                } else: {
                    self boundMethod _ run: selector with: arguments in: receiver
                }
            }(
                self receiver _ evaluateNodeWith: evaluationEnvironment,
                self selector evaluateNodeWith: evaluationEnvironment,
                self arguments collect: {:(SysmelCompiler AST Node)arg :: AnyValue |
                    arg evaluateNodeWith: evaluationEnvironment
                }
            )
        }
    }.

SysmelCompiler Semantic IdentifierLookupScope
    withSelector: #lookupSymbol: addMethod: {:(SysmelCompiler Semantic IdentifierLookupScope)self :(AnyValue)symbol :: SysmelCompiler Semantic SymbolBinding optional |
        <primitive: #"identifierLookupScope.lookupSymbol">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSymbolRecursively: addMethod: {:(SysmelCompiler Semantic IdentifierLookupScope)self :(AnyValue)symbol :: SysmelCompiler Semantic SymbolBinding optional |
        <primitive: #"identifierLookupScope.lookupSymbolRecursively">
        __BootstrapCompiler__ primitiveFailed
    }.

SysmelCompiler Semantic SymbolBinding
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(SysmelCompiler Semantic SymbolBinding)self :(SysmelCompiler AST IdentifierReferenceNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    }.

SysmelCompiler Semantic SymbolImmutableValueBinding
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(SysmelCompiler Semantic SymbolImmutableValueBinding)self :(SysmelCompiler AST IdentifierReferenceNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        SysmelCompiler AST LiteralValueNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            analyzedType: self value __type__.
            value: self value
        }
    }.

SysmelCompiler Semantic EvaluationEnvironment __type__
    withSelector: #default addMethod: {:(SysmelCompiler Semantic EvaluationEnvironment __type__)self :: self |
        self basicNewWithNamedSlots: #{
            lexicalScope: __BootstrapCompiler__ getTopLevelEnvironment
        }
    };
    withSelector: #forScriptEvaluationScope: addMethod: {:(SysmelCompiler Semantic EvaluationEnvironment __type__)self :(SysmelCompiler Semantic ScriptEvaluationScope)scope :: self |
        self basicNewWithNamedSlots: #{
            lexicalScope: scope
        }
    }.

SysmelCompiler Semantic ASTAnalyzer __type__
    withSelector: #forEnvironment: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer __type__)self :(SysmelCompiler Semantic EvaluationEnvironment)environment :: self |
        self basicNewWithNamedSlots: #{
            environment: environment
        }
    };
    withSelector: #forScriptEvaluationScope: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer __type__)self :(SysmelCompiler Semantic ScriptEvaluationScope)scope :: self |
        self forEnvironment: (SysmelCompiler Semantic EvaluationEnvironment forScriptEvaluationScope: scope)
    };
    withSelector: #forDefaultEnvironment addMethod: {:(SysmelCompiler Semantic ASTAnalyzer __type__)self :: self |
        self forEnvironment: SysmelCompiler Semantic EvaluationEnvironment default
    }.

SysmelCompiler Semantic ASTAnalyzer
    withSelector: #makeSemanticAnalysisError:at: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(String)errorMessage :(SysmelCompiler AST SourcePosition)sourcePosition :: SysmelCompiler AST SemanticErrorNode |
        SysmelCompiler AST SemanticErrorNode basicNewWithNamedSlots: #{
            analyzedType: CompilationError.
            sourcePosition: sourcePosition.
            message: errorMessage.
        }.
    }.

Type
    withSelector: #lookupSelector: addMethod: {:(Type)self :(AnyValue)selector :: AnyValue |
        <primitive: #"type.lookupSelector">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: node selector isLiteralValueNode then: {
            {:(AnyValue)selector :: SysmelCompiler AST Node |
                {:(AnyValue)method :: SysmelCompiler AST Node |
                    if: method isNil then: {
                        analyzer makeSemanticAnalysisError: "TODO: analyze message with message not found." at: node sourcePosition
                    } else: {
                        method analyzeMessageSendNode: node with: analyzer
                    }
                } (self lookupSelector: selector)
            }(node selector evaluateLiteralValue)
        } else: {
            analyzer makeSemanticAnalysisError: "TODO: Unsupported message sends without literal selectors." at: node sourcePosition
        }
    }.

Function __type__
    withSelector: #canonicalArgumentTypes addMethod: {:(Function)self :: Type arraySlice |
        <primitive: #"functionType.getCanonicalArgumentTypes">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canonicalResultType addMethod: {:(Function)self :: Type |
        <primitive: #"functionType.getCanonicalResultType">
        __BootstrapCompiler__ primitiveFailed
    }.

Function
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Function)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        node shallowCopy
            arguments: (node arguments collectWithIndex: {:(SysmelCompiler AST Node)node :(Size)argumentIndex :: SysmelCompiler AST Node |
                node analyzeNodeIfNeededWith: analyzer
            });
            analyzedType: self __type__ canonicalResultType;
            boundMethod: self;
            yourself.
    };
    withSelector: #run:with:in: addMethod: {:(Function)self :(AnyValue)selector :(AnyValue arraySlice)arguments :(AnyValue)receiver :: AnyValue |
        <primitive: #"object.runWithIn">
        __BootstrapCompiler__ primitiveFailed
    }.

if: (Boolean basicNew: true) then: {
__BootstrapCompiler__
    print: false;
    print: true;
    print: nil;
    print: Boolean basicNew;
    print: (Boolean basicNew: false);
    print: (Boolean basicNew: true);

    print: 1 + 1;
    print: 2 * 3;
    print: 6 // 3;

    print: 2 = 2;

    print: "Some number: " -- 1 asString;
    print: ("Some number: {0} " format: (1 asString,));

    print: ((Integer array: 3sz) basicNewWithSlots: (1, 2, 3)) asArraySlice;
    print: (((Integer array: 3sz) basicNewWithSlots: (1, 2, 3)) asArraySlice collect: {:(Integer)x :: Size |
        x sz
    });
    print: (((Integer array: 3sz) basicNewWithSlots: (1, 2, 3)) asArraySlice collectWithIndex: {:(Integer)x :(Size)index :: Size |
        index
    });

    print: SysmelCompiler AST SourcePosition basicNew;
    print: (SysmelCompiler AST Node basicNewWithNamedSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition basicNew
    });
    print: Int32 basicNew;
    print: (Int32 basicNew: -42);
    print: SysmelCompiler Semantic ASTAnalyzer __type__;

    print: (`'1 analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'1 analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'(1 + 1) analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'(1 + 1) analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'{} analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'{} analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'{1 . 1 + 1} analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'{1 . 1 + 1} analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: nil isNil;
    print: nil isNotNil.

if: (Boolean basicNew: true) then: {
    __BootstrapCompiler__ print: "then branch"
} else: {
    __BootstrapCompiler__ print: "else branch"
}.
} else: {}.

## At the end of this phase we can enable the actual type system.
__BootstrapCompiler__
    enableTypeSystem
