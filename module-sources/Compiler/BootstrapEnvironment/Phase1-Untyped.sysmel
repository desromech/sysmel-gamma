## This is the Phase1, where the core basic type system is defined along with the global bindings.
## In this stage the compiler environment itself is completely empty,
## except for a single reference to the bootstrap compiler itself.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Type theory fundamentals
    addBasicTypeNamed: #Absurd with: __TypeBuilder__ newAbsurdType;
    addBasicTypeNamed: #Trivial with: __TypeBuilder__ newTrivialType;

    addBasicTypeNamed: #False with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #True with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Boolean with: (__TypeBuilder__ newSumTypeWith: (False, True));
    addBasicTypeNamed: #Undefined with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Void with: __TypeBuilder__ newTrivialType;

    ## Base type system
    addBasicTypeNamed: #AnyValue with: (__TypeBuilder__ newGCClassWithSlots: #{});

    addBasicTypeNamed: #Object with: (__TypeBuilder__ newGCClassWithSuperclass: AnyValue slots: #{});
    addBasicTypeNamed: #Type with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #SimpleType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});
    addBasicTypeNamed: #MetaType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});

    addBasicTypeNamed: #TypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #TrivialTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #AbsurdTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #SumTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #PrimitiveTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #ProductTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #RecordTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: ProductTypeSchema slots: #{});
    addBasicTypeNamed: #GCClassTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: RecordTypeSchema slots: #{});
    addBasicTypeNamed: #ArrayTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #PointerTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});
    addBasicTypeNamed: #ReferenceTypeSchema with: (__TypeBuilder__ newGCClassWithSuperclass: TypeSchema slots: #{});

    addBasicTypeNamed: #Tuple with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Function with: (__TypeBuilder__ newGCClassWithSuperclass: SimpleType slots: #{});
    addBasicTypeNamed: #FunctionImplementation with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #BlockClosure with: (__TypeBuilder__ newGCClassWithSuperclass: FunctionImplementation slots: #{});
    addBasicTypeNamed: #AbstractPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: FunctionImplementation slots: #{});
    addBasicTypeNamed: #PrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #TypeSchemaPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeAccessorPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: AbstractPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeGetterPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: RecordTypeAccessorPrimitiveMethod slots: #{});
    addBasicTypeNamed: #RecordTypeSetterPrimitiveMethod with: (__TypeBuilder__ newGCClassWithSuperclass: RecordTypeAccessorPrimitiveMethod slots: #{});

    addBasicTypeNamed: #String with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Symbol with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Integer with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Float with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    
    addBasicTypeNamed: #CompilationError with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{}).

AnyValue addTypeFlag: #anyValue.


## Object primitives.
AnyValue
    withSelector: #== addMethod: {:(AnyValue)self :(AnyValue)other :: Boolean |
        <pure>
        <primitive: #"object.comparison.identityEquals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #~~ addMethod: {:(AnyValue)self :(AnyValue)other :: Boolean |
        <pure>
        <primitive: #"object.comparison.identityNotEquals">
        __BootstrapCompiler__ primitiveFailed
    }.

## Boolean primitives
Boolean
    withSelector: #| addMethod: {:(Boolean)self :(Boolean)other :: Boolean |
        <pure>
        if: self then: {
            true
        } else: {
            other
        }
    };
    withSelector: #& addMethod: {:(Boolean)self :(Boolean)other :: Boolean |
        <pure>
        if: self then: {
            other
        } else: {
            false
        }
    };
    withSelector: #not addMethod: {:(Boolean)self :: Boolean |
        if: self then: {
            false
        } else: {
            true
        }
    }.

## Integer arithmetics primitive methods
Integer
    withSelector: #negated addMethod: {:(Integer)self :: Integer |
        <pure>
        <primitive: #"integer.arithmetic.neg">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #+ addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <primitive: #"integer.arithmetic.add">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #- addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <primitive: #"integer.arithmetic.sub">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #"*" addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <primitive: #"integer.arithmetic.mul">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #// addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <primitive: #"integer.arithmetic.div">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #% addMethod: {:(Integer)self :(Integer)other :: Integer |
        <pure>
        <primitive: #"integer.arithmetic.rem">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <primitive: #"integer.comparison.equals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #~= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <primitive: #"integer.comparison.notEquals">
        __BootstrapCompiler__ primitiveFailed
    };
    
    withSelector: #< addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <primitive: #"integer.comparison.lessThan">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #<= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <primitive: #"integer.comparison.lessOrEqual">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #> addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <primitive: #"integer.comparison.greaterThan">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #>= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <pure>
        <primitive: #"integer.comparison.greaterOrEqual">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #asString addMethod: {:(Integer)self :: String |
        <pure>
        <primitive: #"integer.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Integer)self :: String |
        <pure>
        <primitive: #"integer.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    }.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Important keywords
    addKeywordBindingNamed: #false with: False basicNew;
    addKeywordBindingNamed: #true with: True basicNew;
    addKeywordBindingNamed: #nil with: Undefined basicNew;
    addKeywordBindingNamed: #void with: Void basicNew;

    ## The primitive types
    addBasicTypeNamed: #Boolean8 with: (__TypeBuilder__ newBooleanTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Boolean16 with: (__TypeBuilder__ newBooleanTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Boolean32 with: (__TypeBuilder__ newBooleanTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #UInt8 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #UInt16 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #UInt32 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #UInt64 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Int8 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Int16 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Int32 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Int64 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Char8 with: (__TypeBuilder__ newCharacterTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Char16 with: (__TypeBuilder__ newCharacterTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Char32 with: (__TypeBuilder__ newCharacterTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #Float16 with: (__TypeBuilder__ newFloatTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Float32 with: (__TypeBuilder__ newFloatTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Float64 with: (__TypeBuilder__ newFloatTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #UIntPointer with: (if: __BootstrapCompiler__ getPointerSize = 4 then: UInt32 else: UInt64);
    addBasicTypeNamed: #IntPointer with: (if: __BootstrapCompiler__ getPointerSize = 4 then: Int32 else: Int64);
    addBasicTypeNamed: #Size with: UIntPointer.

## Integer conversion primitives
Integer
    withSelector: #u8 addMethod: {:(Integer)self :: UInt8 |
        <pure>
        <primitive: #"integer.conversion.toUInt8">
        UInt8 basicNew: self
    };
    withSelector: #s8 addMethod: {:(Integer)self :: Int8 |
        <pure>
        <primitive: #"integer.conversion.toInt8">
        Int8 basicNew: self
    };
    withSelector: #u16 addMethod: {:(Integer)self :: UInt16 |
        <pure>
        <primitive: #"integer.conversion.toUInt16">
        UInt16 basicNew: self
    };
    withSelector: #s16 addMethod: {:(Integer)self :: Int16 |
        <pure>
        <primitive: #"integer.conversion.toInt16">
        Int16 basicNew: self
    };
    withSelector: #u32 addMethod: {:(Integer)self :: UInt32 |
        <pure>
        <primitive: #"integer.conversion.toUInt32">
        UInt32 basicNew: self
    };
    withSelector: #s32 addMethod: {:(Integer)self :: Int32 |
        <pure>
        <primitive: #"integer.conversion.toInt32">
        Int32 basicNew: self
    };
    withSelector: #u64 addMethod: {:(Integer)self :: UInt64 |
        <pure>
        <primitive: #"integer.conversion.toUInt64">
        UInt64 basicNew: self
    };
    withSelector: #s64 addMethod: {:(Integer)self :: Int64 |
        <pure>
        <primitive: #"integer.conversion.toInt64">
        Int64 basicNew: self
    };

    withSelector: #sz addMethod: {:(Integer)self :: Size |
        <pure>
        <primitive: #"integer.conversion.toSize">
        Size basicNew: self
    };
    withSelector: #uptr addMethod: {:(Integer)self :: UIntPointer |
        <pure>
        <primitive: #"integer.conversion.toUIntPointer">
        UIntPointer basicNew: self
    };
    withSelector: #uptr addMethod: {:(Integer)self :: IntPointer |
        <pure>
        <primitive: #"integer.conversion.toIntPointer">
        IntPointer basicNew: self
    }.

{:addPrimitivesBlock |
    addPrimitivesBlock(UInt8).
    addPrimitivesBlock(Int8).
    addPrimitivesBlock(UInt16).
    addPrimitivesBlock(Int16).
    addPrimitivesBlock(UInt32).
    addPrimitivesBlock(Int32).
    addPrimitivesBlock(UInt64).
    addPrimitivesBlock(Int64).
}({:(Type)primitiveIntegerType |
    primitiveIntegerType
        withSelector: #negated addMethod: {:(primitiveIntegerType)self :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.neg">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #+ addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.add">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #- addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.sub">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #"*" addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.mul">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #// addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.div">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #% addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: primitiveIntegerType |
            <pure>
            <primitive: #"primitiveInteger.arithmetic.rem">
            __BootstrapCompiler__ primitiveFailed
        };

        withSelector: #= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.equals">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #~= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.notEquals">
            __BootstrapCompiler__ primitiveFailed
        };
        
        withSelector: #< addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.lessThan">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #<= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.lessOrEqual">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #> addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.greaterThan">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #>= addMethod: {:(primitiveIntegerType)self :(primitiveIntegerType)other :: Boolean |
            <pure>
            <primitive: #"primitiveInteger.comparison.greaterOrEqual">
            __BootstrapCompiler__ primitiveFailed
        };

        withSelector: #asString addMethod: {:(Integer)self :: String |
            <pure>
            <primitive: #"primitiveInteger.conversion.toString">
            __BootstrapCompiler__ primitiveFailed
        };
        withSelector: #printString addMethod: {:(Integer)self :: String |
            <pure>
            <primitive: #"primitiveInteger.conversion.toString">
            __BootstrapCompiler__ primitiveFailed
        }.
}).

__BootstrapCompiler__
    enterTopLevelNamespace;
    
    ## The polymorphic types
    addBasicTypeNamed: #Optional with: {:(Type)optionalType :: Type |
        let: #sumType with: (__TypeBuilder__ newSumTypeWith: (Undefined, optionalType)).

        sumType
            withSelector: #isNil addMethod: {:(sumType)self :: Boolean |
                <pure>
                self __typeSelector__ = 0sz
            };
            withSelector: #isNotNil addMethod: {:(sumType)self :: Boolean |
                <pure>
                self __typeSelector__ ~= 0sz
            };
            withSelector: #_ addMethod: {:(sumType)self :: optionalType |
                <pure>
                self get: optionalType
            };
            withSelector: #value addMethod: {:(sumType)self :: optionalType |
                <pure>
                self get: optionalType
            }.
        sumType
    } templated;

    addBasicTypeNamed: #Array with: {:(Type)elementType :(Size)bounds :: Type |
        let: #arrayType with: (__TypeBuilder__ newArrayTypeFor: elementType withBounds: bounds).
        arrayType
            withSelector: #asArraySlice addMethod: {:(arrayType)self :: ArraySlice(elementType) |
                <pure>
                ArraySlice(elementType) basicNewWithNamedSlots: #{
                    elements: self.
                    size: bounds
                }
            };
            withSelector: #size addMethod: {:(arrayType)self :: Size |
                <pure>
                bounds
            }.
        arrayType
    } templated;

    addBasicTypeNamed: #Pointer with: {:(Type)elementType :: Type |
        __TypeBuilder__ newPointerTypeFor: elementType
    } templated;

    addBasicTypeNamed: #ArraySlice with: {:(Type)elementType :: Type |
        let: #arraySliceType with: (__TypeBuilder__ newRecordTypeWith: #{
            elements: Pointer(elementType).
            size: Size.
        }).

        arraySliceType
            addTypeFlag: #arraySlice;
            withSelector: #isEmpty addMethod: {:(arraySliceType)self :: Boolean |
                <pure>
                self size = 0sz
            };
            withSelector: #isNotEmpty addMethod: {:(arraySliceType)self :: Boolean |
                <pure>
                self size ~= 0sz
            };
            withSelector: #basicAt: addMethod: {:(arraySliceType)self :(Size)index :: elementType |
                <pure>
                self elements basicAt: index
            };
            withSelector: #first addMethod: {:(arraySliceType)self :: elementType |
                <pure>
                self basicAt: 0sz
            };
            withSelector: #last addMethod: {:(arraySliceType)self :: elementType |
                <pure>
                self basicAt: self size - 1sz
            };
            withSelector: #collect: addMethod: {:*(Type)ResultType :(elementType => ResultType)block :: ArraySlice(ResultType) |
                <pure>
                <primitive: #"arraySlice.collect">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #collectWithIndex: addMethod: {:*(Type)ResultType :((elementType -- Size) => ResultType)block :: ArraySlice(ResultType) |
                <pure>
                <primitive: #"arraySlice.collectWithIndex">
                __BootstrapCompiler__ primitiveFailed
            };
            withSelector: #do: addMethod: {:*(Type)ResultType :((elementType) => ResultType)block :: ResultType |
                <pure>
                <primitive: #"arraySlice.do">
                __BootstrapCompiler__ primitiveFailed
            }.
        arraySliceType
    } templated;
    addBasicTypeNamed: #AnyArraySlice with: ArraySlice(AnyValue);

    addBasicTypeNamed: #Association with: {:(Type)key :(Type)value :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            key: key.
            value: value.
        }
    } templated;
    addBasicTypeNamed: #AnyAssociation with: Association(AnyValue, AnyValue);

    addBasicTypeNamed: #ArrayDictionary with: {:(Type)keyType :(Type)valueType :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            associationList: ArraySlice(Association(keyType, valueType)).
            hashTable: ArraySlice(UInt32).
        }
    } templated;
    addBasicTypeNamed: #AnyArrayDictionary with: ArrayDictionary(AnyValue, AnyValue);

    addBasicTypeNamed: #ArrayList with: {:(Type)elementType :: Type |
        __TypeBuilder__ newGCClassWithSlots: #{
            size: Size.
            storage: ArraySlice(elementType)
        }
    } templated;
    addBasicTypeNamed: #AnyArrayList with: ArrayList(AnyValue);

    addBasicTypeNamed: #Tuple with: {:*(Size)N :(Type array: N)elementTypes :: Type |
        let: #tupleType with: (__TypeBuilder__ newProductTypeWith: elementTypes).
        tupleType __type__
            withSelector: #-- addMethod: {:(Type)self :(Type) nextType :: Type |
                <override>
                __TypeBuilder__ extendTupleType: self with: nextType
            };
            withSelector: #=> addMethod: {:(Type)self :(Type) resultType :: Type |
                <override>
                __TypeBuilder__ newSimpleFunctionTypeWithArguments: self resultType: resultType
            }.
        tupleType
    } templated;

    addBasicTypeNamed: #ValueBox with: {:(Type)elementType :: Type |
        let: #valueBoxType with: (__TypeBuilder__ newGCClassWithSlots: #{
            _: elementType
        }).
        valueBoxType __type__
            withSelector: #with: addMethod: {:(valueBoxType __type__)self :(elementType)value :: self |
                self basicNewWithNamedSlots: {
                    _: value
                }
            }.
        valueBoxType
    } templated;
    addBasicTypeNamed: #AnyValueBox with: ArrayList(AnyValue).

## String primitive methods
String
    withSelector: #-- addMethod: {:(String)self :(String)other :: String |
        <pure>
        <primitive: #"string.concat">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #format: addMethod: {:(String)self :(String arraySlice)parameters :: String |
        <pure>
        <primitive: #"string.format">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asSymbol addMethod: {:(String)self :: Symbol |
        <pure>
        <primitive: #"symbol.internString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asString addMethod: {:(String)self :: String |
        <pure>
        self
    };
    withSelector: #printString addMethod: {:(String)self :: String |
        <pure>
        <primitive: #"string.conversion.printString">
        self
    }.

Symbol
    withSelector: #asString addMethod: {:(Integer)self :: String |
        <pure>
        <primitive: #"symbol.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Integer)self :: String |
        <pure>
        <primitive: #"symbol.conversion.printString">
        __BootstrapCompiler__ primitiveFailed
    }.

## Basic type system methods.
Type
    withSelector: #-- addMethod: {:(Type)self :(Type)second :: Type |
        <pure>
        <virtual>
        __TypeBuilder__ newPairType: self with: second
    };
    withSelector: #=> addMethod: {:(Type)self :(Type) resultType :: Type |
        <pure>
        <virtual>
        __TypeBuilder__ newSimpleFunctionTypeWithArgument: self resultType: resultType
    }.

Void __type__
    withSelector: #=> addMethod: {:(Type)self :(Type) resultType :: Type |
        <pure>
        <override>
        __TypeBuilder__ newSimpleFunctionTypeWithResultType: resultType
    }.

## Basic type system methods.
MetaType
    withSelector: #"[]" addMethod: {:(Type)self :: Type |
        <pure>
        Array(self, 0)
    };
    withSelector: #"[]" addMethod: {:(Type)self :(Size)bounds :: Type |
        <pure>
        Array(self, bounds)
    };
    withSelector: #optional addMethod: {:(Type)self :: Type |
        <pure>
        Optional(self)
    };
    withSelector: #array addMethod: {:(Type)self :: Type |
        <pure>
        Array(self, 0)
    };
    withSelector: #array: addMethod: {:(Type)self :(Size)bounds :: Type |
        <pure>
        Array(self, bounds)
    };
    withSelector: #arraySlice addMethod: {:(Type)self :: Type |
        <pure>
        ArraySlice(self)
    };
    withSelector: #arrayList addMethod: {:(Type)self :: Type |
        <pure>
        ArrayList(self)
    };
    withSelector: #valueBox addMethod: {:(Type)self :: Type |
        <pure>
        ArrayList(self)
    }.

## Basic methods.
AnyValue
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <virtual>
        false
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <virtual>
        true
    }.

Undefined
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <override>
        true
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        <pure>
        <override>
        false
    }.

## The AST nodes.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #SysmelCompiler;
    enterNamespaceNamed: #AST;
    addBindingNamed: #SourceCollection with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourcePosition with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourceStringCollection with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourceCollection publicSlots: #{
        sourceString: String.
        name: String.
    });
    addBindingNamed: #SourceStringPosition with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourcePosition publicSlots: #{
        sourceCollection: SysmelCompiler AST SourceCollection.
        startPosition: Size.
        endPosition: Size.
        startLine: Size.
        startColumn: Size.
        endLine: Size.
        endColumn: Size.
    });
    addBindingNamed: #EmptySourcePosition with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourcePosition publicSlots: #{});

    addBindingNamed: #Node with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition.
        analyzedType: Type optional
    });
    addBindingNamed: #ArgumentDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        name: SysmelCompiler AST Node.
        type: SysmelCompiler AST Node.
    });
    addBindingNamed: #BlockClosureNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        arguments: SysmelCompiler AST Node arraySlice.
        body: SysmelCompiler AST Node.
    });
    addBindingNamed: #ChainedMessageNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        selector: SysmelCompiler AST Node.
        arguments: SysmelCompiler AST Node arraySlice
    });
    addBindingNamed: #CleanUpScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        body: SysmelCompiler AST Node.
        cleanUpAction: SysmelCompiler AST Node optional.
    });
    addBindingNamed: #LexicalScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        body: SysmelCompiler AST Node
    });
    addBindingNamed: #LiteralValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        value: AnyValue
    });
    addBindingNamed: #IdentifierReferenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        value: AnyValue.
        binding: AnyValue.
    });

    addBindingNamed: #MakeAssociationNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        key: SysmelCompiler AST Node.
        value: SysmelCompiler AST Node.
    });
    addBindingNamed: #MakeTupleNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        elements: SysmelCompiler AST Node arraySlice.
    });
    addBindingNamed: #MakeDictionaryNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        elements: SysmelCompiler AST Node arraySlice.
    });

    addBindingNamed: #MessageSendNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        receiver: SysmelCompiler AST Node optional.
        selector: SysmelCompiler AST Node.
        arguments: SysmelCompiler AST Node arraySlice.
        boundMethod: AnyValue optional.
        usesDynamicDispatch: Boolean.
    });
    addBindingNamed: #MessageChainNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        receiver: SysmelCompiler AST Node.
        chainedMessages: SysmelCompiler AST Node arraySlice
    });
    addBindingNamed: #SequenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expressions: SysmelCompiler AST Node arraySlice.
        pragmas: SysmelCompiler AST Node arraySlice.
    });

    addBindingNamed: #SpliceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuasiQuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuasiUnquoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });

    addBindingNamed: #ErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        message: String
    });
    addBindingNamed: #ParseErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST ErrorNode publicSlots: #{});
    addBindingNamed: #SemanticErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST ErrorNode publicSlots: #{});

    addBindingNamed: #IfTrueIfFalseNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        condition: SysmelCompiler AST Node.
        trueExpression: SysmelCompiler AST Node optional.
        falseExpression: SysmelCompiler AST Node optional.
    });
    addBindingNamed: #WhileDoContinueNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        condition: SysmelCompiler AST Node.
        bodyExpression: SysmelCompiler AST Node optional.
        continueExpression: SysmelCompiler AST Node optional.
    });
    addBindingNamed: #LocalVariableDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        nameExpression: SysmelCompiler AST Node.
        typeExpression: SysmelCompiler AST Node optional.
        initialValueExpression: SysmelCompiler AST Node.

        analyzedSymbol: AnyValue optional.
        analyzedExpectedValueType: Type optional.
    });

    ## Basic type conversion nodes
    addBindingNamed: #TypeConversionNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #ValueAsVoidNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST TypeConversionNode publicSlots: #{});
    addBindingNamed: #WrapValueInSumTypeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST TypeConversionNode publicSlots: #{
        typeSelector: Size.
    });
    addBindingNamed: #WrapAnyValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST TypeConversionNode publicSlots: #{});
    addBindingNamed: #UnwrapAnyValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST TypeConversionNode publicSlots: #{});

    ## Stablish the basic ast node mapping that is required for converting a parse tree onto the actual AST object.
    setParseTreeASTMaping: #{
        SourceCollection: SysmelCompiler AST SourceCollection.
        SourcePosition: SysmelCompiler AST SourcePosition.
        SourceStringCollection: SysmelCompiler AST SourceStringCollection.
        SourceStringPosition: SysmelCompiler AST SourceStringPosition.
        EmptySourcePosition: SysmelCompiler AST EmptySourcePosition.

        Node: SysmelCompiler AST Node.
        NodeArrayList: SysmelCompiler AST Node arrayList.
        NodeArraySlice: SysmelCompiler AST Node arraySlice.

        ArgumentDefinitionNode: SysmelCompiler AST ArgumentDefinitionNode.
        BlockClosureNode: SysmelCompiler AST BlockClosureNode.
        ChainedMessageNode: SysmelCompiler AST ChainedMessageNode.
        CleanUpScopeNode: SysmelCompiler AST CleanUpScopeNode.
        IdentifierReferenceNode: SysmelCompiler AST IdentifierReferenceNode.
        LexicalScopeNode: SysmelCompiler AST LexicalScopeNode.
        LiteralValueNode: SysmelCompiler AST LiteralValueNode.
        MakeAssociationNode: SysmelCompiler AST MakeAssociationNode.
        MakeDictionaryNode: SysmelCompiler AST MakeDictionaryNode.
        MakeTupleNode: SysmelCompiler AST MakeTupleNode.
        MessageSendNode: SysmelCompiler AST MessageSendNode.
        MessageChainNode: SysmelCompiler AST MessageChainNode.
        QuoteNode: SysmelCompiler AST QuoteNode.
        QuasiQuoteNode: SysmelCompiler AST QuasiQuoteNode.
        QuasiUnquoteNode: SysmelCompiler AST QuasiUnquoteNode.
        SequenceNode: SysmelCompiler AST SequenceNode.
        SpliceNode: SysmelCompiler AST SpliceNode.

        ErrorNode: SysmelCompiler AST ErrorNode.
        ParseErrorNode: SysmelCompiler AST ParseErrorNode.
        SemanticErrorNode: SysmelCompiler AST SemanticErrorNode.
    }.

## Semantic analysis types.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #SysmelCompiler;
    enterNamespaceNamed: #Semantic;
    addBindingNamed: #SymbolBinding with: (__TypeBuilder__ newGCClassWithPublicSlots: #{});
    addBindingNamed: #SymbolValueBinding with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic SymbolBinding publicSlots: #{
        name: AnyValue.
        value: AnyValue
    });
    addBindingNamed: #IdentifierLookupScope with: (__TypeBuilder__ newGCClassWithPublicSlots: #{});
    addBindingNamed: #LexicalScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic IdentifierLookupScope publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #NamespaceScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic LexicalScope publicSlots: #{});
    addBindingNamed: #ScriptEvaluationScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic LexicalScope publicSlots: #{});
    addBindingNamed: #EvaluationEnvironment with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        lexicalScope: SysmelCompiler Semantic LexicalScope
    });
    addBindingNamed: #TypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithPublicSlots: #{});
    addBindingNamed: #ExpectedTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic TypeInferenceEnvironment publicSlots: #{
        expectedType: Type
    });
    addBindingNamed: #AutoTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic TypeInferenceEnvironment publicSlots: #{});
    addBindingNamed: #DirectAutoTypeInferenceEnvironment with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic TypeInferenceEnvironment publicSlots: #{});
    addBindingNamed: #ASTAnalyzer with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        environment: SysmelCompiler Semantic EvaluationEnvironment.
        typeInferenceEnvironment: SysmelCompiler Semantic TypeInferenceEnvironment.
    });
    setSemanticAnalysisMapping: #{
        SymbolBinding: SysmelCompiler Semantic SymbolBinding.
        SymbolValueBinding: SysmelCompiler Semantic SymbolValueBinding.
        IdentifierLookupScope: SysmelCompiler Semantic IdentifierLookupScope.
        LexicalScope: SysmelCompiler Semantic LexicalScope.
        NamespaceScope: SysmelCompiler Semantic NamespaceScope.
        ScriptEvaluationScope: SysmelCompiler Semantic ScriptEvaluationScope.
        EvaluationEnvironment: SysmelCompiler Semantic EvaluationEnvironment.
        ASTAnalyzer: SysmelCompiler Semantic ASTAnalyzer.
    }.

## Macro invocation context.
__BootstrapCompiler__
    enterTopLevelNamespace;
    addBindingNamed: #MacroInvocationContext with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition.
        selfNode: SysmelCompiler AST Node optional.
        selfType: Type.
        astAnalyzer: SysmelCompiler Semantic ASTAnalyzer.
    }).

SysmelCompiler AST Node
    withSelector: #analyzeNodeIfNeededWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self analyzedType isNil then: {
            self analyzeNodeWith: analyzer
        } else: {
            self
        }
    };
    withSelector: #analyzeAndEvaluateNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: AnyValue |
        (self analyzeNodeIfNeededWith: analyzer) evaluateNodeWith: analyzer environment
    };
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #isLiteralValueNode addMethod: {:(SysmelCompiler AST Node)self :: Boolean |
        false
    };
    withSelector: #evaluateLiteralValue addMethod: {:(SysmelCompiler AST Node)self :: AnyValue |
        __BootstrapCompiler__ error: "Not a literal value node."
    };
    withSelector: #analyzeAndEvaluateNodeWithScriptEvaluationScope: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ScriptEvaluationScope)scope :: AnyValue |
        self analyzeAndEvaluateNodeWith: (SysmelCompiler Semantic ASTAnalyzer forScriptEvaluationScope: scope)
    }.

SysmelCompiler AST SourceStringCollection
    withSelector: #printString addMethod: {:(SysmelCompiler AST SourceStringCollection)self :: String |
        self name
    }.

SysmelCompiler AST SourceStringPosition
    withSelector: #printString addMethod: {:(SysmelCompiler AST SourceStringCollection)self :: String |
        "{0}:{1}.{2}-{3}.{4}" format: (self sourceCollection printString,
            self startLine printString, self startColumn printString,
            self endLine printString, self endColumn printString,
        )
    }.

SysmelCompiler AST LiteralValueNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST LiteralValueNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self shallowCopy
            analyzedType: self value __type__;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST LiteralValueNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self value
    };
    withSelector: #isLiteralValueNode addMethod: {:(SysmelCompiler AST LiteralValueNode)self :: Boolean |
        true
    };
    withSelector: #evaluateLiteralValue addMethod: {:(SysmelCompiler AST LiteralValueNode)self :: AnyValue |
        self value
    }.

SysmelCompiler AST CleanUpScopeNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST CleanUpScopeNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #analyzedBody with: (analyzer analyzeNodeIfNeededWithCurrentExpectedType: self body).
        self shallowCopy
            body: analyzedBody;
            analyzedType: analyzedBody analyzedType _;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self body evaluateNodeWith: evaluationEnvironment
    }.

SysmelCompiler AST LexicalScopeNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST LexicalScopeNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #analyzedBody with: (analyzer analyzeNodeIfNeededWithCurrentExpectedType: self body).
        self shallowCopy
            body: analyzedBody;
            analyzedType: analyzedBody analyzedType _;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self body evaluateNodeWith: evaluationEnvironment
    }.

SysmelCompiler AST SequenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST SequenceNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #analyzedPragmas with: (self pragmas collect: {:(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
                analyzer analyzedNodeIfNeeded: node withExpectedType: Pragma
        }).
        let: #analyzedExpressions with: (self expressions collectWithIndex: {:(SysmelCompiler AST Node)node :(Size)index :: SysmelCompiler AST Node |
                if: index + 1sz < self expressions size then: {
                    analyzer analyzeNodeIfNeeded: node withExpectedType: Void.
                } else: {
                    analyzer analyzeNodeIfNeededWithCurrentExpectedType: node
                }
        }).

        self shallowCopy
            pragmas: analyzedPragmas;
            expressions: analyzedExpressions;
            analyzedType: (if: analyzedExpressions isEmpty then: Void else: analyzedExpressions last analyzedType _);
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self expressions do: {:(SysmelCompiler AST Node)node :: AnyValue |
            node evaluateNodeWith: evaluationEnvironment
        }
    }.

SysmelCompiler AST IdentifierReferenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST IdentifierReferenceNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #binding with: (analyzer environment lexicalScope lookupSymbolRecursively: self value).
        
        if: binding isNil then: {
            analyzer makeSemanticAnalysisError: ("Failed to binding for symbol {0}." format: (self value printString, )) at: self sourcePosition
        } else: {
            binding _ analyzeIdentifierReferenceNode: self with: analyzer
        }
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self binding evaluateBindingWithEnvironment: evaluationEnvironment
    }.

SysmelCompiler AST MessageSendNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST MessageSendNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #analyzedSelector with: (analyzer analyzeNodeIfNeededWithAutoType: self selector).
        if: self receiver isNil then: {
            if: analyzedSelector isLiteralValueNode then: {
                let: #binding with: (analyzer environment lexicalScope lookupSymbolRecursively: (analyzedSelector evaluateNodeWith: analyzer)).

                if: binding isNil then: {
                    analyzer makeSemanticAnalysisError: ("Failed to binding for selector {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
                } else: {
                    binding _ analyzeMessageSendNode: (self shallowCopy
                        selector: analyzedSelector;
                        yourself) with: analyzer
                }
            } else: {
                analyzer makeSemanticAnalysisError: ("Message  {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
            }
        } else: {
            let: #analyzedReceiver with: (analyzer analyzeNodeIfNeededWithDirectAutoType: self receiver _ ).
            analyzedReceiver analyzedType _ analyzeMessageSendNode: (self shallowCopy
                receiver: analyzedReceiver;
                selector: analyzedSelector;
                yourself) with: analyzer
        }.
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST MessageSendNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: self receiver isNil then: {
            self boundMethod run: (self selector evaluateNodeWith: evaluationEnvironment) with: (self arguments collect: {:(SysmelCompiler AST Node)arg :: AnyValue |
                arg evaluateNodeWith: evaluationEnvironment
            }) in: nil
        } else: {
            let: #receiver with: (self receiver _ evaluateNodeWith: evaluationEnvironment).
            let: #selector with: (self selector evaluateNodeWith: evaluationEnvironment).
            let: #arguments with: (self arguments collect: {:(SysmelCompiler AST Node)arg :: AnyValue |
                    arg evaluateNodeWith: evaluationEnvironment
            }).

            if: self usesDynamicDispatch | self boundMethod isNil then: {
                receiver perform: selector withArguments: arguments
            } else: {
                self boundMethod _ run: selector with: arguments in: receiver
            }
        }
    }.

SysmelCompiler AST ParseErrorNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST ParseErrorNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self shallowCopy
            analyzedType: CompilationError;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ parseError: self message at: self sourcePosition
    }.

SysmelCompiler AST SemanticErrorNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST SemanticErrorNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self shallowCopy
            analyzedType: CompilationError;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST SemanticErrorNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ semanticAnalysisError: self message at: self sourcePosition
    }.

SysmelCompiler AST IfTrueIfFalseNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST IfTrueIfFalseNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #analyzedNode with: self shallowCopy.

        analyzedNode condition: (analyzer analyzeNodeIfNeeded: self condition withExpectedType: Boolean).
        ## Initial per-branch analysis
        if: analyzedNode trueExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode trueExpression: (analyzer analyzeNodeIfNeededWithCurrentExpectedType: analyzedNode trueExpression _)
        }.

        if: analyzedNode falseExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode falseExpression:  (analyzer analyzeNodeIfNeededWithCurrentExpectedType: analyzedNode falseExpression _)
        }.

        ## Compute the result type.
        if: analyzedNode falseExpression isNil | analyzedNode trueExpression isNil then: {
            analyzedNode analyzedType: Void
        } else: {
            analyzedNode analyzedType: (analyzer computeBranchResultTypeOf: analyzedNode falseExpression _ analyzedType _ with: analyzedNode trueExpression _ analyzedType _)
        }.

        if: analyzedNode trueExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode trueExpression: (analyzer analyzeNodeIfNeeded: analyzedNode trueExpression _ withExpectedType: analyzedNode analyzedType _)
        }.

        if: analyzedNode falseExpression isNil then: {
            ## Nothing is required here.
        } else: {
            analyzedNode falseExpression: (analyzer analyzeNodeIfNeeded: analyzedNode falseExpression _ withExpectedType: analyzedNode analyzedType _)
        }.

        analyzedNode
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST IfTrueIfFalseNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: (self condition evaluateNodeWith: evaluationEnvironment) then: {
            if: self trueExpression isNil then: {
                void
            } else: {
                self trueExpression _ evaluateNodeWith: evaluationEnvironment
            }
        } else: {
            if: self falseExpression isNil then: {
                void
            } else: {
                self falseExpression _ evaluateNodeWith: evaluationEnvironment
            }
        }
    }.

SysmelCompiler AST WhileDoContinueNode
withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST WhileDoContinueNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        let: #analyzedNode with: self shallowCopy.

        analyzedNode
            condition: (analyzer analyzeNodeIfNeeded: self condition withExpectedType: Boolean);
            analyzedType: Void.

        ## Body expression.
        if: analyzedNode bodyExpression isNil then: {
            ## Nothing is required here
        } else: {
            analyzedNode bodyExpression: (analyzer analyzeNodeIfNeeded: analyzedNode bodyExpression _ withExpectedType: Void)
        }.

        ## Continue expression.
        if: analyzedNode continueExpression isNil then: {
            ## Nothing is required here
        } else: {
            analyzedNode continueExpression: (analyzer analyzeNodeIfNeeded: analyzedNode continueExpression _ withExpectedType: Void)
        }.

        analyzedNode
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST WhileDoContinueNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        while: (self condition evaluateNodeWith: evaluationEnvironment) do: {
            if: self bodyExpression isNil then: {
                void
            } else: {
                self bodyExpression _ evaluateNodeWith: evaluationEnvironment
            }
        } continueWith: {
            if: self continueExpression isNil then: {
                void
            } else: {
                self continueExpression _ evaluateNodeWith: evaluationEnvironment
            }
        }
    }.

SysmelCompiler AST ValueAsVoidNode
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST ValueAsVoidNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self expression evaluateNodeWith: evaluationEnvironment.
        void
    }.

SysmelCompiler AST WrapValueInSumTypeNode
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST WrapValueInSumTypeNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self analyzedType _ basicNew: (self expression evaluateNodeWith: evaluationEnvironment) typeSelector: self typeSelector
    }.

SysmelCompiler AST WrapAnyValueNode
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST WrapValueInSumTypeNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        ## This is a nop in the evaluator.
        self expression evaluateNodeWith: evaluationEnvironment
    }.
SysmelCompiler AST UnwrapAnyValueNode
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST WrapValueInSumTypeNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        ## This is a nop in the evaluator.
        self expression evaluateNodeWith: evaluationEnvironment
    }.

SysmelCompiler Semantic IdentifierLookupScope
    withSelector: #lookupSymbol: addMethod: {:(SysmelCompiler Semantic IdentifierLookupScope)self :(AnyValue)symbol :: SysmelCompiler Semantic SymbolBinding optional |
        <primitive: #"identifierLookupScope.lookupSymbol">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSymbolRecursively: addMethod: {:(SysmelCompiler Semantic IdentifierLookupScope)self :(AnyValue)symbol :: SysmelCompiler Semantic SymbolBinding optional |
        <primitive: #"identifierLookupScope.lookupSymbolRecursively">
        __BootstrapCompiler__ primitiveFailed
    }.

SysmelCompiler Semantic SymbolBinding
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(SysmelCompiler Semantic SymbolBinding)self :(SysmelCompiler AST IdentifierReferenceNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    }.

SysmelCompiler Semantic SymbolValueBinding
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self value __type__ analyzeMessageSendNode: node with: analyzer valueBinding: self
    };
    withSelector: #analyzeIdentifierReferenceNode:with: addMethod: {:(SysmelCompiler Semantic SymbolValueBinding)self :(SysmelCompiler AST IdentifierReferenceNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self value __type__ analyzeIdentifierReferenceNode: node with: analyzer valueBinding: self
    }.

SysmelCompiler Semantic EvaluationEnvironment __type__
    withSelector: #default addMethod: {:(SysmelCompiler Semantic EvaluationEnvironment __type__)self :: self |
        self basicNewWithNamedSlots: #{
            lexicalScope: __BootstrapCompiler__ getTopLevelEnvironment.
        }
    };
    withSelector: #forScriptEvaluationScope: addMethod: {:(SysmelCompiler Semantic EvaluationEnvironment __type__)self :(SysmelCompiler Semantic ScriptEvaluationScope)scope :: self |
        self basicNewWithNamedSlots: #{
            lexicalScope: scope
        }
    }.

SysmelCompiler Semantic ASTAnalyzer __type__
    withSelector: #forEnvironment: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer __type__)self :(SysmelCompiler Semantic EvaluationEnvironment)environment :: self |
        self basicNewWithNamedSlots: #{
            environment: environment.
            typeInferenceEnvironment: SysmelCompiler Semantic AutoTypeInferenceEnvironment basicNew.
        }
    };
    withSelector: #forScriptEvaluationScope: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer __type__)self :(SysmelCompiler Semantic ScriptEvaluationScope)scope :: self |
        self forEnvironment: (SysmelCompiler Semantic EvaluationEnvironment forScriptEvaluationScope: scope)
    };
    withSelector: #forDefaultEnvironment addMethod: {:(SysmelCompiler Semantic ASTAnalyzer __type__)self :: self |
        self forEnvironment: SysmelCompiler Semantic EvaluationEnvironment default
    }.

SysmelCompiler Semantic TypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(SysmelCompiler Semantic TypeInferenceEnvironment)self :(SysmelCompiler AST Node)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer |
        __BootstrapCompiler__ subclassResponsibility
    }.

SysmelCompiler Semantic DirectAutoTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(SysmelCompiler Semantic TypeInferenceEnvironment)self :(SysmelCompiler AST Node)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        node
    }.

SysmelCompiler Semantic AutoTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(SysmelCompiler Semantic TypeInferenceEnvironment)self :(SysmelCompiler AST Node)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node  |
        analyzer addImplicitCoercionTo: node analyzedType _ asDecayedType node: node
    }.

SysmelCompiler Semantic ExpectedTypeInferenceEnvironment
    withSelector: #solveAnalyzedNodeType:with: addMethod: {:(SysmelCompiler Semantic TypeInferenceEnvironment)self :(SysmelCompiler AST Node)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node  |
        analyzer addImplicitCoercionTo: self expectedType node: node
    }.

SysmelCompiler Semantic ASTAnalyzer
    withSelector: #makeSemanticAnalysisError:at: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(String)errorMessage :(SysmelCompiler AST SourcePosition)sourcePosition :: SysmelCompiler AST SemanticErrorNode |
        SysmelCompiler AST SemanticErrorNode basicNewWithNamedSlots: #{
            analyzedType: CompilationError.
            sourcePosition: sourcePosition.
            message: errorMessage.
        }.
    };

    withSelector: #makeMacroInvocationContextForMessageSendNodeNode: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST MessageSendNode)node :: MacroInvocationContext |
        MacroInvocationContext basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            selfNode: node receiver.
            selfType: (if: node receiver isNil then: {
                Void
            } else: {
                if: node receiver _ analyzedType isNil then: Void then: node receiver _ analyzedType
            }).
            astAnalyzer: self
        }
    };

    withSelector: #analyzeNodeIfNeededWithDirectAutoType: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: SysmelCompiler Semantic DirectAutoTypeInferenceEnvironment basicNew
    };
    withSelector: #analyzeNodeIfNeededWithAutoType: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: SysmelCompiler Semantic AutoTypeInferenceEnvironment basicNew
    };
    withSelector: #analyzeNodeIfNeeded:withEnvironment: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST Node)node :(SysmelCompiler Semantic EvaluationEnvironment)environment :: SysmelCompiler AST Node |
        let: #oldEnvironment with: self environment.
        self environment: environment.

        let: #analyzedNode with: (self analyzeNodeIfNeededWithCurrentExpectedType: node).
        self environment: oldEnvironment.

        analyzedNode
    };
    withSelector: #analyzeNodeIfNeeded:withTypeInferenceEnvironment: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST Node)node :(SysmelCompiler Semantic TypeInferenceEnvironment)typeInferenceEnvironment :: SysmelCompiler AST Node |
        let: #oldTypeInferenceEnvironment with: (self typeInferenceEnvironment).
        self typeInferenceEnvironment: typeInferenceEnvironment.

        let: #analyzedNode with: (self analyzeNodeIfNeededWithCurrentExpectedType: node).
        self typeInferenceEnvironment: oldTypeInferenceEnvironment.
        analyzedNode
    };
    
    withSelector: #analyzeNodeIfNeeded:withExpectedType: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST Node)node :(Type)expectedType :: SysmelCompiler AST Node |
        self analyzeNodeIfNeeded: node withTypeInferenceEnvironment: (SysmelCompiler Semantic ExpectedTypeInferenceEnvironment basicNewWithNamedSlots: #{
            expectedType: expectedType
        })
    };
    withSelector: #analyzeNodeIfNeededWithCurrentExpectedType: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
        self typeInferenceEnvironment solveAnalyzedNodeType: (node analyzeNodeIfNeededWith: self) with: self
    };
    withSelector: #computeBranchResultTypeOf:with: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(Type)leftType :(Type)rightType :: Type |
        if: leftType == rightType then: {
            leftType
        } else: {
            Void
        }
    };
    withSelector: #addImplicitCoercionTo:node: addMethod: {:(SysmelCompiler Semantic ASTAnalyzer)self :(Type)targetType :(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
        node analyzedType _ addImplicitCoercionToNode: node targetType: targetType with: self
    }.

Type
    withSelector: #asString addMethod: {:(Type)self :: String |
        <pure>
        <primitive: #"type.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #printString addMethod: {:(Type)self :: String |
        <pure>
        <primitive: #"type.conversion.toString">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #lookupSelector: addMethod: {:(Type)self :(AnyValue)selector :: AnyValue |
        <primitive: #"type.lookupSelector">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Type)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: node selector isLiteralValueNode then: {
            let: #selector with: (node selector evaluateLiteralValue).
            let: #method with: (self lookupSelector: selector).

            if: method isNil then: {
                self analyzeUnboundMessageSendNode: node with: analyzer
            } else: {
                method analyzeMessageSendNode: node with: analyzer
            }
        } else: {
            self analyzeUnboundMessageSendNode: node with: analyzer
        }
    };
    withSelector: #analyzeUnboundMessageSendNode:with: addMethod: {:(Type)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        analyzer makeSemanticAnalysisError: "Unsupported unbound message send." at: node sourcePosition
    };
    withSelector: #analyzeIdentifierReferenceNode:with:valueBinding: addMethod: {:(SysmelCompiler Semantic SymbolValueBinding)self :(SysmelCompiler AST IdentifierReferenceNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :(SysmelCompiler Semantic SymbolValueBinding)binding :: SysmelCompiler AST Node |
        SysmelCompiler AST LiteralValueNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            analyzedType: self.
            value: binding value
        }
    };
    withSelector: #supportsDynamicDispatch addMethod: {:(Type)self :: AnyValue |
        <primitive: #"type.supportsDynamicDispatch">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #asDecayedType addMethod: {:(Type)self :: Type |
        self
    };
    withSelector: #schema addMethod: {:(Type)self :: TypeSchema |
        <primitive: #"type.getSchema">
        self
    };
    withSelector: #hasTypeFlag: addMethod: {:(Type)self :(AnyValue)methodFlag :: Boolean |
        <primitive: #"type.hasTypeFlag">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #hasAnyValueFlag addMethod: {:(Type)self :: Boolean |
        self hasTypeFlag: #anyValue
    };

    withSelector: #addImplicitCoercionToNode:targetType:with: addMethod: {:(Type)self
        :(SysmelCompiler AST Node)node :(Type)targetType :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self == targetType then: {
            node
        } else: {
            targetType addImplicitCoercionToNode: node fromType: self with: analyzer
        }
    };
    withSelector: #addImplicitCoercionToNode:fromType:with: addMethod: {:(Type)self
        :(SysmelCompiler AST Node)node :(Type)fromType :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self == fromType then: {
            node
        } else: {
            if: self hasAnyValueFlag then: {
                WrapAnyValueNode basicNewWithNamedSlots: #{
                    sourcePosition: node sourcePosition.
                    expression: node.
                    analyzedType: self
                }
            } else: {
                if: (self schema canConstructWithValueOfType: fromType) then: {
                    self schema addConstructionNodeFor: node valueType: fromType into: self with: analyzer
                } else: {
                    analyzer makeSemanticAnalysisError: ("Failed to perform implicit conversion {0} -> {1}" format: (fromType printString, self printString)) at: node sourcePosition
                }
            }
        }
    }.

TypeSchema 
    withSelector: #canConstructWithValueOfType: addMethod: {:(TypeSchema)self :(Type)sourceType :: Boolean |
        Boolean basicNew: false
    };
    withSelector: #addConstructionNodeFor:valueType:into:with: addMethod: {:(TypeSchema)self :(SysmelCompiler AST Node)node :(Type)sourceType :(Type)targetType :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    }.

SumTypeSchema 
    withSelector: #containsType: addMethod: {:(SumTypeSchema)self :(Type)typeToCheck :: Boolean |
        <primitive: #"sumTypeSchema.containsType" >
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #getTypeSelectorIndexFor: addMethod: {:(SumTypeSchema)self :(Type)elementType :: Size |
        <primitive: #"sumTypeSchema.getTypeSelectorIndexFor" >
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canConstructWithValueOfType: addMethod: {:(SumTypeSchema)self :(Type)sourceType :: Boolean |
        self containsType: sourceType
    };
    withSelector: #addConstructionNodeFor:valueType:into:with: addMethod: {:(TypeSchema)self :(SysmelCompiler AST Node)node :(Type)sourceType :(Type)targetType :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        SysmelCompiler AST WrapValueInSumTypeNode basicNewWithNamedSlots: #{
            sourcePosition: node sourcePosition.
            expression: node.
            typeSelector: (self getTypeSelectorIndexFor: sourceType).
            analyzedType: targetType.
        }
    }.

Void __type__
    withSelector: #addImplicitCoercionToNode:fromType:with: addMethod: {:(Type)self
        :(SysmelCompiler AST Node)node :(Type)fromType :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self == fromType then: {
            node
        } else: {
            SysmelCompiler AST ValueAsVoidNode basicNewWithNamedSlots: #{
                sourcePosition: node sourcePosition.
                expression: node.
                analyzedType: self
            }
        }
    }.

Function __type__
    withSelector: #canonicalArgumentTypes addMethod: {:(Function __type__)self :: Type arraySlice |
        <primitive: #"functionType.getCanonicalArgumentTypes">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #canonicalResultType addMethod: {:(Function __type__)self :: Type |
        <primitive: #"functionType.getCanonicalResultType">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #analyzeMessageSendNode:with:valueBinding: addMethod: {:(Function __type__)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :(SysmelCompiler Semantic SymbolValueBinding)binding :: SysmelCompiler AST Node |
        binding value analyzeMessageSendNode: node with: analyzer
    }.

Function
    withSelector: #analyzeMessageSendNode:with: addMethod: {:(Function)self :(SysmelCompiler AST MessageSendNode)node :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self hasMacroFlag then: {
            analyzer analyzeNodeIfNeededWithCurrentExpectedType: (self
                run: (node selector analyzeAndEvaluateNodeWith: analyzer)
                with: node arguments
                in: (analyzer makeMacroInvocationContextForMessageSendNodeNode: node)
            )
        } else: {
            node shallowCopy
                arguments: (node arguments collectWithIndex: {:(SysmelCompiler AST Node)node :(Size)argumentIndex :: SysmelCompiler AST Node |
                    analyzer analyzeNodeIfNeededWithAutoType: node
                });
                analyzedType: self __type__ canonicalResultType;
                boundMethod: self;
                usesDynamicDispatch: node receiver _ analyzedType _ supportsDynamicDispatch & self usesDynamicDispatch;
                yourself
        }.
    };
    withSelector: #run:with:in: addMethod: {:(Function)self :(AnyValue)selector :(AnyValue arraySlice)arguments :(AnyValue)receiver :: AnyValue |
        <primitive: #"object.runWithIn">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #hasMethodFlag: addMethod: {:(Function)self :(AnyValue)methodFlag :: Boolean |
        <primitive: #"function.hasMethodFlag">
        __BootstrapCompiler__ primitiveFailed
    };

    ## Macro
    withSelector: #hasMacroFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #macro
    };
    withSelector: #hasMessageMethodFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #messageMethod
    };
    withSelector: #hasFallbackFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #fallback
    };

    ## Side effects
    withSelector: #hasPureFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #pure
    };

    ## Dispatch mode
    withSelector: #hasAbstractFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #abstract
    };
    withSelector: #hasVirtualFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #virtual
    };
    withSelector: #hasOverrideFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #override
    };
    withSelector: #hasStaticFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #static
    };
    withSelector: #hasFinalFlag addMethod: {:(Function)self :: Boolean |
        self hasMethodFlag: #final
    };

    withSelector: #hasDynamicDispatchFlag addMethod: {:(Function)self :: Boolean |
        self hasAbstractFlag | self hasVirtualFlag | self hasOverrideFlag
    };

    withSelector: #usesDynamicDispatch addMethod: {:(Function)self :: Boolean |
        self hasDynamicDispatchFlag & self hasFinalFlag not 
    }.

__BootstrapCompiler__
    enterTopLevelNamespace;
    addBindingNamed: #if:then:else: with: {:(MacroInvocationContext)macroSelf :(SysmelCompiler AST Node)condition :(SysmelCompiler AST Node)trueExpression :(SysmelCompiler AST Node)falseExpression :: (SysmelCompiler AST IfTrueIfFalseNode) |
        <macro>
        (SysmelCompiler AST IfTrueIfFalseNode basicNewWithNamedSlots: #{
            sourcePosition: macroSelf sourcePosition.
            condition: condition.
            trueExpression: trueExpression.
            falseExpression: falseExpression.
        })
    };
    addBindingNamed: #if:then: with: {:(MacroInvocationContext)macroSelf :(SysmelCompiler AST Node)condition :(SysmelCompiler AST Node)trueExpression :: (SysmelCompiler AST IfTrueIfFalseNode) |
        <macro>
        (SysmelCompiler AST IfTrueIfFalseNode basicNewWithNamedSlots: #{
            sourcePosition: macroSelf sourcePosition.
            condition: condition.
            trueExpression: trueExpression.
        })
    };
    addBindingNamed: #while:do:continueWith: with: {:(MacroInvocationContext)macroSelf :(SysmelCompiler AST Node)condition :(SysmelCompiler AST Node)bodyExpression :(SysmelCompiler AST Node)continueExpression :: (SysmelCompiler AST WhileDoContinueNode) |
        <macro>
        (SysmelCompiler AST WhileDoContinueNode basicNewWithNamedSlots: #{
            sourcePosition: macroSelf sourcePosition.
            condition: condition.
            bodyExpression: bodyExpression.
            continueExpression: continueExpression
        })
    };
    addBindingNamed: #while:do: with: {:(MacroInvocationContext)macroSelf :(SysmelCompiler AST Node)condition :(SysmelCompiler AST Node)bodyExpression :: (SysmelCompiler AST WhileDoContinueNode) |
        <macro>
        (SysmelCompiler AST WhileDoContinueNode basicNewWithNamedSlots: #{
            sourcePosition: macroSelf sourcePosition.
            condition: condition.
            bodyExpression: bodyExpression.
        })
    };
    addBindingNamed: #let:with: with: {:(MacroInvocationContext)macroSelf :(SysmelCompiler AST Node)nameExpression :(SysmelCompiler AST Node)initialValueExpression :: (SysmelCompiler AST LocalVariableDefinitionNode) |
        <macro>
        (SysmelCompiler AST LocalVariableDefinitionNode basicNewWithNamedSlots: #{
            sourcePosition: macroSelf sourcePosition.
            nameExpression: nameExpression.
            initialValueExpression: initialValueExpression.
        })
    };
    addBindingNamed: #let:type:with: with: {:(MacroInvocationContext)macroSelf :(SysmelCompiler AST Node)nameExpression :(SysmelCompiler AST Node)typeExpression :(SysmelCompiler AST Node)initialValueExpression :: (SysmelCompiler AST LocalVariableDefinitionNode) |
        <macro>
        (SysmelCompiler AST LocalVariableDefinitionNode basicNewWithNamedSlots: #{
            sourcePosition: macroSelf sourcePosition.
            nameExpression: nameExpression.
            typeExpression: typeExpression;
            initialValueExpression: initialValueExpression.
        })
    }.


if: (Boolean basicNew: true) then: {
__BootstrapCompiler__
    print: false;
    print: true;
    print: nil;
    print: Boolean basicNew;
    print: (Boolean basicNew: false);
    print: (Boolean basicNew: true);

    print: 1 + 1;
    print: 2 * 3;
    print: 6 // 3;

    print: 2 = 2;

    print: "Some number: " -- 1 asString;
    print: ("Some number: {0} " format: (1 asString,));

    print: ((Integer array: 3sz) basicNewWithSlots: (1, 2, 3)) asArraySlice;
    print: (((Integer array: 3sz) basicNewWithSlots: (1, 2, 3)) asArraySlice collect: {:(Integer)x :: Size |
        x sz
    });
    print: (((Integer array: 3sz) basicNewWithSlots: (1, 2, 3)) asArraySlice collectWithIndex: {:(Integer)x :(Size)index :: Size |
        index
    });

    print: SysmelCompiler AST SourcePosition basicNew;
    print: (SysmelCompiler AST Node basicNewWithNamedSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition basicNew
    });
    print: Int32 basicNew;
    print: (Int32 basicNew: -42);
    print: SysmelCompiler Semantic ASTAnalyzer __type__;

    print: (`'1 analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'1 analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'(1 + 1) analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'(1 + 1) analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'{} analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'{} analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'{1 . 1 + 1} analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'{1 . 1 + 1} analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'(1 negated) analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'(if: true then: 1 else: 2) analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'(if: true then: 1 else: 2) analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'(if: false then: 1 else: 2) analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: (`'(if: true then: 1) analyzeNodeIfNeededWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);
    print: (`'(if: false then: 1) analyzeAndEvaluateNodeWith: SysmelCompiler Semantic ASTAnalyzer forDefaultEnvironment);

    print: nil isNil;
    print: nil isNotNil;

    print: Int32 => Void;
    print: Void => Void;
    print: (Int32 -- Int32) => Void;
    print: (Int32 -- Int32 -- Int32) => Void;
    print: Float32 -- Int32 -- Float64.

if: (Boolean basicNew: true) then: {
    __BootstrapCompiler__ print: "then branch"
} else: {
    __BootstrapCompiler__ print: "else branch"
}.
} else: {}.

## At the end of this phase we can enable the actual type system.
__BootstrapCompiler__
    enableTypeSystem
