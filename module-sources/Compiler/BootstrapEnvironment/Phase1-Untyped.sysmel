## This is the Phase1, where the core basic type system is defined along with the global bindings.
## In this stage the compiler environment itself is completely empty,
## except for a single reference to the bootstrap compiler itself.

__BootstrapCompiler__
    enterTopLevelNamespace;

    ## Type theory fundamentals
    addBasicTypeNamed: #Absurd with: __TypeBuilder__ newAbsurdType;
    addBasicTypeNamed: #Trivial with: __TypeBuilder__ newTrivialType;

    addBasicTypeNamed: #False with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #True with: __TypeBuilder__ newTrivialType;
    addBasicTypeNamed: #Boolean with: (__TypeBuilder__ newSumTypeWith: (False, True));
    addBasicTypeNamed: #Undefined with: __TypeBuilder__ newTrivialType;

    ## Base type system
    addBasicTypeNamed: #AnyValue with: (__TypeBuilder__ newGCClassWithSlots: #{});

    addBasicTypeNamed: #Object with: (__TypeBuilder__ newGCClassWithSuperclass: AnyValue slots: #{});
    addBasicTypeNamed: #Type with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #SimpleType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});
    addBasicTypeNamed: #MetaType with: (__TypeBuilder__ newGCClassWithSuperclass: Type slots: #{});

    addBasicTypeNamed: #String with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Symbol with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Integer with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});
    addBasicTypeNamed: #Float with: (__TypeBuilder__ newGCClassWithSuperclass: Object slots: #{});

    ## Important keywords
    addKeywordBindingNamed: #false with: False basicNew;
    addKeywordBindingNamed: #true with: True basicNew;
    addKeywordBindingNamed: #nil with: Undefined basicNew;

    ## The primitive types
    addBasicTypeNamed: #Boolean8 with: (__TypeBuilder__ newBooleanTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Boolean16 with: (__TypeBuilder__ newBooleanTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Boolean32 with: (__TypeBuilder__ newBooleanTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #UInt8 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #UInt16 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #UInt32 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #UInt64 with: (__TypeBuilder__ newUnsignedIntegerTypeWithSize: 8 alignment: 8);

    ## TODO: Add support for 32 bits targets:
    addBasicTypeNamed: #UIntPointer with: UInt64;
    addBasicTypeNamed: #IntPointer with: UInt64;
    addBasicTypeNamed: #Size with: UIntPointer;

    addBasicTypeNamed: #Int8 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Int16 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Int32 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Int64 with: (__TypeBuilder__ newSignedIntegerTypeWithSize: 8 alignment: 8);

    addBasicTypeNamed: #Char8 with: (__TypeBuilder__ newCharacterTypeWithSize: 1 alignment: 1);
    addBasicTypeNamed: #Char16 with: (__TypeBuilder__ newCharacterTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Char32 with: (__TypeBuilder__ newCharacterTypeWithSize: 4 alignment: 4);

    addBasicTypeNamed: #Float16 with: (__TypeBuilder__ newFloatTypeWithSize: 2 alignment: 2);
    addBasicTypeNamed: #Float32 with: (__TypeBuilder__ newFloatTypeWithSize: 4 alignment: 4);
    addBasicTypeNamed: #Float64 with: (__TypeBuilder__ newFloatTypeWithSize: 8 alignment: 8);

    ## The polymorphic types
    addBindingNamed: #Optional with: {:(Type)optionalType :: Type |
        {:(Type)sumType :: Type |
            sumType
                withSelector: #isNil addMethod: {:(sumType)self :: Boolean |
                    self __typeSelector__ = 0
                };
                withSelector: #isNotNil addMethod: {:(sumType)self :: Boolean |
                    self __typeSelector__ ~= 0
                }.
            sumType
        }(__TypeBuilder__ newSumTypeWith: (Undefined, optionalType))
    } templated;

    addBindingNamed: #Array with: {:(Type)elementType :(Integer)bounds :: Type |
        __TypeBuilder__ newArrayTypeFor: elementType withBounds: bounds
    } templated;

    addBindingNamed: #Pointer with: {:(Type)elementType :: Type |
        __TypeBuilder__ newPointerTypeFor: elementType
    } templated;

    addBindingNamed: #ArraySlice with: {:(Type)elementType :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            elements: Pointer(elementType).
            size: Size.
        }
    } templated;
    addBasicTypeNamed: #AnyArraySlice with: ArraySlice(AnyValue);

    addBindingNamed: #Association with: {:(Type)key :(Type)value :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            key: key.
            value: value.
        }
    } templated;
    addBasicTypeNamed: #AnyAssociation with: Association(AnyValue, AnyValue);

    addBindingNamed: #ArrayDictionary with: {:(Type)keyType :(Type)valueType :: Type |
        __TypeBuilder__ newRecordTypeWith: #{
            associationList: ArraySlice(Association(keyType, valueType)).
            hashTable: ArraySlice(UInt32).
        }
    } templated;
    addBasicTypeNamed: #AnyArrayDictionary with: ArrayDictionary(AnyValue, AnyValue);

    addBindingNamed: #ArrayList with: {:(Type)elementType :: Type |
        __TypeBuilder__ newGCClassWithSlots: #{
            size: Size.
            storage: ArraySlice(elementType)
        }
    } templated;
    addBasicTypeNamed: #AnyArrayList with: ArrayList(AnyValue).

## Integer arithmetics primitive methods
Integer
    withSelector: #+ addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.add">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #- addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.sub">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #"*" addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.mul">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #// addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.div">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #% addMethod: {:(Integer)self :(Integer)other :: Integer |
        <primitive: #"integer.arithmetic.rem">
        __BootstrapCompiler__ primitiveFailed
    };

    withSelector: #= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.equals">
        __BootstrapCompiler__ primitiveFailed
    };
    withSelector: #~= addMethod: {:(Integer)self :(Integer)other :: Boolean |
        <primitive: #"integer.comparison.notEquals">
        __BootstrapCompiler__ primitiveFailed
    }.

## Basic type system methods.
MetaType
    withSelector: #"[]" addMethod: {:(Type)self :: Type |
        Array(self, 0)
    };
    withSelector: #"[]" addMethod: {:(Type)self :(Integer)bounds :: Type |
        Array(self, bounds)
    };
    withSelector: #optional addMethod: {:(Type)self :: Type |
        Optional(self)
    };
    withSelector: #arraySlice addMethod: {:(Type)self :: Type |
        ArraySlice(self)
    };
    withSelector: #arrayList addMethod: {:(Type)self :: Type |
        ArrayList(self)
    }.

## Basic methods.
Undefined
    withSelector: #isNil addMethod: {:(Undefined)self :: Boolean |
        true
    };
    withSelector: #isNotNil addMethod: {:(Undefined)self :: Boolean |
        false
    }.

## The AST nodes.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #SysmelCompiler;
    enterNamespaceNamed: #AST;
    addBindingNamed: #SourceCollection with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourcePosition with: (__TypeBuilder__ newGCClassWithSlots: #{});
    addBindingNamed: #SourceStringCollection with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourceCollection publicSlots: #{
        sourceString: String.
        name: String.
    });
    addBindingNamed: #SourceStringPosition with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourcePosition publicSlots: #{
        sourceCollection: SysmelCompiler AST SourceCollection.
        startPosition: Integer.
        endPosition: Integer.
        startLine: Integer.
        startColumn: Integer.
        endLine: Integer.
        endColumn: Integer.
    });
    addBindingNamed: #EmptySourcePosition with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST SourcePosition publicSlots: #{});

    addBindingNamed: #Node with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition.
        analyzedType: Type optional
    });
    addBindingNamed: #ArgumentDefinitionNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        name: SysmelCompiler AST Node.
        type: SysmelCompiler AST Node.
    });
    addBindingNamed: #BlockClosureNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        arguments: SysmelCompiler AST Node arraySlice.
        body: SysmelCompiler AST Node.
    });
    addBindingNamed: #ChainedMessageNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        selector: SysmelCompiler AST Node.
        arguments: SysmelCompiler AST Node arraySlice
    });
    addBindingNamed: #CleanUpScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        body: SysmelCompiler AST Node.
        cleanUpAction: SysmelCompiler AST Node optional.
    });
    addBindingNamed: #LexicalScopeNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        body: SysmelCompiler AST Node
    });
    addBindingNamed: #LiteralValueNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        value: AnyValue
    });
    addBindingNamed: #IdentifierReferenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        value: AnyValue.
        binding: AnyValue.
    });

    addBindingNamed: #MakeAssociationNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        key: SysmelCompiler AST Node.
        value: SysmelCompiler AST Node.
    });
    addBindingNamed: #MakeTupleNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        elements: SysmelCompiler AST Node arraySlice.
    });
    addBindingNamed: #MakeDictionaryNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        elements: SysmelCompiler AST Node arraySlice.
    });

    addBindingNamed: #MessageSendNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        receiver: SysmelCompiler AST Node.
        selector: SysmelCompiler AST Node.
        arguments: SysmelCompiler AST Node arraySlice.
        boundMessage: AnyValue optional.
    });
    addBindingNamed: #MessageChainNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        receiver: SysmelCompiler AST Node.
        chainedMessages: SysmelCompiler AST Node arraySlice
    });
    addBindingNamed: #SequenceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expressions: SysmelCompiler AST Node arraySlice.
        pragmas: SysmelCompiler AST Node arraySlice.
    });

    addBindingNamed: #SpliceNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuasiQuoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #QuasiUnquoteNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        expression: SysmelCompiler AST Node.
    });

    addBindingNamed: #ErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST Node publicSlots: #{
        message: String
    });
    addBindingNamed: #ParseErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST ErrorNode publicSlots: #{});
    addBindingNamed: #SemanticErrorNode with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler AST ErrorNode publicSlots: #{});

    ## Stablish the basic ast node mapping that is required for converting a parse tree onto the actual AST object.
    setParseTreeASTMaping: #{
        SourceCollection: SysmelCompiler AST SourceCollection.
        SourcePosition: SysmelCompiler AST SourcePosition.
        SourceStringCollection: SysmelCompiler AST SourceStringCollection.
        SourceStringPosition: SysmelCompiler AST SourceStringPosition.
        EmptySourcePosition: SysmelCompiler AST EmptySourcePosition.

        Node: SysmelCompiler AST Node.
        NodeArrayList: SysmelCompiler AST Node arrayList.
        NodeArraySlice: SysmelCompiler AST Node arraySlice.

        ArgumentDefinitionNode: SysmelCompiler AST ArgumentDefinitionNode.
        BlockClosureNode: SysmelCompiler AST BlockClosureNode.
        ChainedMessageNode: SysmelCompiler AST ChainedMessageNode.
        CleanUpScopeNode: SysmelCompiler AST CleanUpScopeNode.
        IdentifierReferenceNode: SysmelCompiler AST IdentifierReferenceNode.
        LexicalScopeNode: SysmelCompiler AST LexicalScopeNode.
        LiteralValueNode: SysmelCompiler AST LiteralValueNode.
        MakeAssociationNode: SysmelCompiler AST MakeAssociationNode.
        MakeDictionaryNode: SysmelCompiler AST MakeDictionaryNode.
        MakeTupleNode: SysmelCompiler AST MakeTupleNode.
        MessageSendNode: SysmelCompiler AST MessageSendNode.
        MessageChainNode: SysmelCompiler AST MessageChainNode.
        QuoteNode: SysmelCompiler AST QuoteNode.
        QuasiQuoteNode: SysmelCompiler AST QuasiQuoteNode.
        QuasiUnquoteNode: SysmelCompiler AST QuasiUnquoteNode.
        SequenceNode: SysmelCompiler AST SequenceNode.
        SpliceNode: SysmelCompiler AST SpliceNode.

        ErrorNode: SysmelCompiler AST ErrorNode.
        ParseErrorNode: SysmelCompiler AST ParseErrorNode.
        SemanticErrorNode: SysmelCompiler AST SemanticErrorNode.
    }.

## Semantic analysis types.
__BootstrapCompiler__
    enterTopLevelNamespace;
    enterNamespaceNamed: #SysmelCompiler;
    enterNamespaceNamed: #Semantic;
    addBindingNamed: #IdentifierLookupScope with: (__TypeBuilder__ newGCClassWithPublicSlots: #{});
    addBindingNamed: #LexicalScope with: (__TypeBuilder__ newGCClassWithSuperclass: SysmelCompiler Semantic IdentifierLookupScope publicSlots: #{
        expression: SysmelCompiler AST Node.
    });
    addBindingNamed: #EvaluationEnvironment with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        lexicalScope: SysmelCompiler Semantic LexicalScope
    });
    addBindingNamed: #ASTAnalyzer with: (__TypeBuilder__ newGCClassWithPublicSlots: #{
        environment: SysmelCompiler Semantic EvaluationEnvironment
    });
    setSemanticAnalysisMapping: #{
        IdentifierLookupScope: SysmelCompiler Semantic IdentifierLookupScope.
        LexicalScope: SysmelCompiler Semantic LexicalScope.
        EvaluationEnvironment: SysmelCompiler Semantic EvaluationEnvironment.
        ASTAnalyzer: SysmelCompiler Semantic ASTAnalyzer.
    }.

SysmelCompiler AST Node
    withSelector: #analyzeNodeIfNeededWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        if: self analyzedType isNil then: {
            self analyzeNodeWith: analyzer
        } else: {
            self
        }
    };
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        __BootstrapCompiler__ subclassResponsibility
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST Node)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        __BootstrapCompiler__ subclassResponsibility
    }.

SysmelCompiler AST LiteralValueNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST LiteralValueNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        self copy
            analyzedType: self value __type__;
            yourself
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST LiteralValueNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self value
    }.

SysmelCompiler AST SequenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST SequenceNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(SysmelCompiler AST Node arraySlice)analyzedPragmas :(SysmelCompiler AST Node arraySlice)analyzedExpressions :: SysmelCompiler AST Node  |
            self copy
                pragmas: analyzedPragmas;
                expressions: analyzedExpressions;
                analyzedType: (analyzedExpressions ifEmpty: Void ifNotEmpty: analyzedExpressions last);
                yourself
        }(
            self pragmas collect: {:(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
                node analyzeNodeIfNeededWith: analyzer
            },
            self expressions collect: {:(SysmelCompiler AST Node)node :: SysmelCompiler AST Node |
                node analyzeNodeIfNeededWith: analyzer
            }
        )
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self expressions do: {:(SysmelCompiler AST Node)node :: AnyValue |
            node evaluateNodeWith: evaluationEnvironment
        }
    }.

SysmelCompiler AST IdentifierReferenceNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST IdentifierReferenceNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: SysmelCompiler AST Node |
        {:(AnyValue)binding :: SysmelCompiler AST Node  |
            if: binding isNil then: {
                __BootstrapCompiler__ makeSemanticAnalysisError: ("Failed to binding for symbol {0}." format: (self value printString, )) at: self sourcePosition
            } else: {
                binding analyzeIdentifierReferenceNode: self with: analyzer
            }
        }(analyzer environment lexicalScope lookupSymbolRecursively: self value)
    };
    withSelector: #evaluateNodeWith: addMethod: {:(Type)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        self binding evaluateBindingWithEnvironment: evaluationEnvironment
    }.

SysmelCompiler AST MessageSendNode
    withSelector: #analyzeNodeWith: addMethod: {:(SysmelCompiler AST MessageSendNode)self :(SysmelCompiler Semantic ASTAnalyzer)analyzer :: Type |
        {:(SysmelCompiler AST)analyzedSelector :: SysmelCompiler AST Node |
            if: self receiver isNil then: {
                if: analyzedSelector isLiteralSymbolValue then: {
                    {:(AnyValue)binding :: SysmelCompiler AST Node |
                        if: binding isNil then: {
                            __BootstrapCompiler__ makeSemanticAnalysisError: ("Failed to binding for selector {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
                        } else: {
                            binding analyzeMessageSendNode: (self copy
                                selector: analyzedSelector;
                                yourself) with: analyzer
                        }
                    } (analyzer environment lexicalScope lookupSymbolRecursively: (analyzedSelector evaluateNodeWith: analyzer))
                } else: {
                    __BootstrapCompiler__ makeSemanticAnalysisError: ("Message  {0}." format: (self analyzedSelector printString, )) at: self sourcePosition
                }
            } else: {
                {:(SysmelCompiler AST)analyzedReceiver :: SysmelCompiler AST Node |
                    analyzedReceiver analyzedType analyzeMessageSendNode: (self copy
                        receiver: analyzedReceiver;
                        selector: analyzedSelector;
                        yourself) with: analyzer
                }(self receiver analyzeNodeIfNeededWith: analyzer)
            }.
        }(self selector analyzeNodeIfNeededWith: analyzer)
    };
    withSelector: #evaluateNodeWith: addMethod: {:(SysmelCompiler AST MessageSendNode)self :(SysmelCompiler Semantic EvaluationEnvironment)evaluationEnvironment :: AnyValue |
        if: self receiver isNil then: {
            self boundMessage run: (self selector evaluateNodeWith: evaluationEnvironment) with: (self arguments collect: {:(SysmelCompiler AST Node)arg :: AnyValue |
                    arg evaluateNodeWith: evaluationEnvironment
                }) in: nil
        } else: {
            {:(AnyValue)receiver :(AnyValue)selector :(AnyValue arraySlice)arguments :: AnyValue |
                if: self boundMessage isNil then: {
                    receiver perform: selector withArguments: argumnets
                } else: {
                    self boundMessage run: selector with: arguments in: receiver
                }
            }(
                self receiver evaluateNodeWith: evaluationEnvironment,
                self selector evaluateNodeWith: evaluationEnvironment,
                self arguments collect: {:(SysmelCompiler AST Node)arg :: AnyValue |
                    arg evaluateNodeWith: evaluationEnvironment
                }
            )
        }
    }.

__BootstrapCompiler__
    print: false;
    print: true;
    print: nil;
    print: Boolean basicNew;
    print: (Boolean basicNew: false);
    print: (Boolean basicNew: true);

    print: SysmelCompiler AST SourcePosition basicNew;
    print: (SysmelCompiler AST Node basicNewWithNamedSlots: #{
        sourcePosition: SysmelCompiler AST SourcePosition basicNew
    });
    print: Int32 basicNew;
    print: (Int32 basicNew: -42);
    ##print: (`'1 analyzedType);
    print: (`'1 analyzeNodeIfNeededWith: (SysmelCompiler Semantic ASTAnalyzer basicNewWithNamedSlots: #{
        environment: __BootstrapCompiler__ getTopLevelEnvironment
    }));
    print: nil isNil;
    print: nil isNotNil.

if: (Boolean basicNew: true) then: {
    __BootstrapCompiler__ print: "then branch"
} else: {
    __BootstrapCompiler__ print: "else branch"
}.

## At the end of this phase we can enable the actual type system.
__BootstrapCompiler__
    enableTypeSystem
